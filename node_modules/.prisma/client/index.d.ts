
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Cliente
 * 
 */
export type Cliente = {
  CPF: string
  Nome: string
  email: string
  senha: string
}

/**
 * Model Prestador
 * 
 */
export type Prestador = {
  CNPJ: string
  Nome: string
  email: string
  Senha: string
}

/**
 * Model Servico
 * 
 */
export type Servico = {
  id: string
  NomeServico: string
  preco: number
  descricao: string
  img: string
  servicoId: string
}

/**
 * Model Categoria
 * 
 */
export type Categoria = {
  id: string
  nomeCategoria: string
  descricao: string
  servicoId: string | null
}

/**
 * Model Agenda
 * 
 */
export type Agenda = {
  id: string
  horario: Date
  dia: Date
  agendaId: string
}

/**
 * Model AgendaStatus
 * 
 */
export type AgendaStatus = {
  id: string
  nomeStatus: string
  descricao: string
  statusId: string
}

/**
 * Model Agendado
 * 
 */
export type Agendado = {
  id: string
  agendadoId: number
}

/**
 * Model Produtos
 * 
 */
export type Produtos = {
  id: string
  nomeProduto: string
  preco: number
  descricao: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clientes
 * const clientes = await prisma.cliente.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clientes
   * const clientes = await prisma.cliente.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<GlobalReject>;

  /**
   * `prisma.prestador`: Exposes CRUD operations for the **Prestador** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prestadors
    * const prestadors = await prisma.prestador.findMany()
    * ```
    */
  get prestador(): Prisma.PrestadorDelegate<GlobalReject>;

  /**
   * `prisma.servico`: Exposes CRUD operations for the **Servico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicos
    * const servicos = await prisma.servico.findMany()
    * ```
    */
  get servico(): Prisma.ServicoDelegate<GlobalReject>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<GlobalReject>;

  /**
   * `prisma.agenda`: Exposes CRUD operations for the **Agenda** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agenda
    * const agenda = await prisma.agenda.findMany()
    * ```
    */
  get agenda(): Prisma.AgendaDelegate<GlobalReject>;

  /**
   * `prisma.agendaStatus`: Exposes CRUD operations for the **AgendaStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgendaStatuses
    * const agendaStatuses = await prisma.agendaStatus.findMany()
    * ```
    */
  get agendaStatus(): Prisma.AgendaStatusDelegate<GlobalReject>;

  /**
   * `prisma.agendado`: Exposes CRUD operations for the **Agendado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agendados
    * const agendados = await prisma.agendado.findMany()
    * ```
    */
  get agendado(): Prisma.AgendadoDelegate<GlobalReject>;

  /**
   * `prisma.produtos`: Exposes CRUD operations for the **Produtos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produtos
    * const produtos = await prisma.produtos.findMany()
    * ```
    */
  get produtos(): Prisma.ProdutosDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.7.1
   * Query Engine version: 272861e07ab64f234d3ffc4094e32bd61775599c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Cliente: 'Cliente',
    Prestador: 'Prestador',
    Servico: 'Servico',
    Categoria: 'Categoria',
    Agenda: 'Agenda',
    AgendaStatus: 'AgendaStatus',
    Agendado: 'Agendado',
    Produtos: 'Produtos'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PrestadorCountOutputType
   */


  export type PrestadorCountOutputType = {
    servicos: number
  }

  export type PrestadorCountOutputTypeSelect = {
    servicos?: boolean
  }

  export type PrestadorCountOutputTypeGetPayload<S extends boolean | null | undefined | PrestadorCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PrestadorCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PrestadorCountOutputTypeArgs)
    ? PrestadorCountOutputType 
    : S extends { select: any } & (PrestadorCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PrestadorCountOutputType ? PrestadorCountOutputType[P] : never
  } 
      : PrestadorCountOutputType




  // Custom InputTypes

  /**
   * PrestadorCountOutputType without action
   */
  export type PrestadorCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PrestadorCountOutputType
     * 
    **/
    select?: PrestadorCountOutputTypeSelect | null
  }



  /**
   * Count Type ServicoCountOutputType
   */


  export type ServicoCountOutputType = {
    categoria: number
  }

  export type ServicoCountOutputTypeSelect = {
    categoria?: boolean
  }

  export type ServicoCountOutputTypeGetPayload<S extends boolean | null | undefined | ServicoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ServicoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ServicoCountOutputTypeArgs)
    ? ServicoCountOutputType 
    : S extends { select: any } & (ServicoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ServicoCountOutputType ? ServicoCountOutputType[P] : never
  } 
      : ServicoCountOutputType




  // Custom InputTypes

  /**
   * ServicoCountOutputType without action
   */
  export type ServicoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ServicoCountOutputType
     * 
    **/
    select?: ServicoCountOutputTypeSelect | null
  }



  /**
   * Count Type AgendadoCountOutputType
   */


  export type AgendadoCountOutputType = {
    status: number
    agenda: number
  }

  export type AgendadoCountOutputTypeSelect = {
    status?: boolean
    agenda?: boolean
  }

  export type AgendadoCountOutputTypeGetPayload<S extends boolean | null | undefined | AgendadoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AgendadoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AgendadoCountOutputTypeArgs)
    ? AgendadoCountOutputType 
    : S extends { select: any } & (AgendadoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AgendadoCountOutputType ? AgendadoCountOutputType[P] : never
  } 
      : AgendadoCountOutputType




  // Custom InputTypes

  /**
   * AgendadoCountOutputType without action
   */
  export type AgendadoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AgendadoCountOutputType
     * 
    **/
    select?: AgendadoCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Cliente
   */


  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteMinAggregateOutputType = {
    CPF: string | null
    Nome: string | null
    email: string | null
    senha: string | null
  }

  export type ClienteMaxAggregateOutputType = {
    CPF: string | null
    Nome: string | null
    email: string | null
    senha: string | null
  }

  export type ClienteCountAggregateOutputType = {
    CPF: number
    Nome: number
    email: number
    senha: number
    _all: number
  }


  export type ClienteMinAggregateInputType = {
    CPF?: true
    Nome?: true
    email?: true
    senha?: true
  }

  export type ClienteMaxAggregateInputType = {
    CPF?: true
    Nome?: true
    email?: true
    senha?: true
  }

  export type ClienteCountAggregateInputType = {
    CPF?: true
    Nome?: true
    email?: true
    senha?: true
    _all?: true
  }

  export type ClienteAggregateArgs = {
    /**
     * Filter which Cliente to aggregate.
     * 
    **/
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClienteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs = {
    where?: ClienteWhereInput
    orderBy?: Enumerable<ClienteOrderByWithAggregationInput>
    by: Array<ClienteScalarFieldEnum>
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }


  export type ClienteGroupByOutputType = {
    CPF: string
    Nome: string
    email: string
    senha: string
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect = {
    CPF?: boolean
    Nome?: boolean
    email?: boolean
    senha?: boolean
  }


  export type ClienteGetPayload<S extends boolean | null | undefined | ClienteArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Cliente :
    S extends undefined ? never :
    S extends { include: any } & (ClienteArgs | ClienteFindManyArgs)
    ? Cliente 
    : S extends { select: any } & (ClienteArgs | ClienteFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Cliente ? Cliente[P] : never
  } 
      : Cliente


  type ClienteCountArgs = Merge<
    Omit<ClienteFindManyArgs, 'select' | 'include'> & {
      select?: ClienteCountAggregateInputType | true
    }
  >

  export interface ClienteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClienteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ClienteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Cliente'> extends True ? Prisma__ClienteClient<ClienteGetPayload<T>> : Prisma__ClienteClient<ClienteGetPayload<T> | null, null>

    /**
     * Find one Cliente that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ClienteFindUniqueOrThrowArgs>
    ): Prisma__ClienteClient<ClienteGetPayload<T>>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClienteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ClienteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Cliente'> extends True ? Prisma__ClienteClient<ClienteGetPayload<T>> : Prisma__ClienteClient<ClienteGetPayload<T> | null, null>

    /**
     * Find the first Cliente that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ClienteFindFirstOrThrowArgs>
    ): Prisma__ClienteClient<ClienteGetPayload<T>>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `CPF`
     * const clienteWithCPFOnly = await prisma.cliente.findMany({ select: { CPF: true } })
     * 
    **/
    findMany<T extends ClienteFindManyArgs>(
      args?: SelectSubset<T, ClienteFindManyArgs>
    ): PrismaPromise<Array<ClienteGetPayload<T>>>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
    **/
    create<T extends ClienteCreateArgs>(
      args: SelectSubset<T, ClienteCreateArgs>
    ): Prisma__ClienteClient<ClienteGetPayload<T>>

    /**
     * Create many Clientes.
     *     @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     *     @example
     *     // Create many Clientes
     *     const cliente = await prisma.cliente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClienteCreateManyArgs>(
      args?: SelectSubset<T, ClienteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
    **/
    delete<T extends ClienteDeleteArgs>(
      args: SelectSubset<T, ClienteDeleteArgs>
    ): Prisma__ClienteClient<ClienteGetPayload<T>>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClienteUpdateArgs>(
      args: SelectSubset<T, ClienteUpdateArgs>
    ): Prisma__ClienteClient<ClienteGetPayload<T>>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClienteDeleteManyArgs>(
      args?: SelectSubset<T, ClienteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClienteUpdateManyArgs>(
      args: SelectSubset<T, ClienteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
    **/
    upsert<T extends ClienteUpsertArgs>(
      args: SelectSubset<T, ClienteUpsertArgs>
    ): Prisma__ClienteClient<ClienteGetPayload<T>>

    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClienteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Cliente base type for findUnique actions
   */
  export type ClienteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
    /**
     * Filter, which Cliente to fetch.
     * 
    **/
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente: findUnique
   */
  export interface ClienteFindUniqueArgs extends ClienteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
    /**
     * Filter, which Cliente to fetch.
     * 
    **/
    where: ClienteWhereUniqueInput
  }


  /**
   * Cliente base type for findFirst actions
   */
  export type ClienteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
    /**
     * Filter, which Cliente to fetch.
     * 
    **/
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClienteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     * 
    **/
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     * 
    **/
    distinct?: Enumerable<ClienteScalarFieldEnum>
  }

  /**
   * Cliente: findFirst
   */
  export interface ClienteFindFirstArgs extends ClienteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
    /**
     * Filter, which Cliente to fetch.
     * 
    **/
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClienteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     * 
    **/
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     * 
    **/
    distinct?: Enumerable<ClienteScalarFieldEnum>
  }


  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
    /**
     * Filter, which Clientes to fetch.
     * 
    **/
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     * 
    **/
    orderBy?: Enumerable<ClienteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     * 
    **/
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ClienteScalarFieldEnum>
  }


  /**
   * Cliente create
   */
  export type ClienteCreateArgs = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
    /**
     * The data needed to create a Cliente.
     * 
    **/
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }


  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs = {
    /**
     * The data used to create many Clientes.
     * 
    **/
    data: Enumerable<ClienteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Cliente update
   */
  export type ClienteUpdateArgs = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
    /**
     * The data needed to update a Cliente.
     * 
    **/
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     * 
    **/
    where: ClienteWhereUniqueInput
  }


  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs = {
    /**
     * The data used to update Clientes.
     * 
    **/
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     * 
    **/
    where?: ClienteWhereInput
  }


  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     * 
    **/
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     * 
    **/
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }


  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
    /**
     * Filter which Cliente to delete.
     * 
    **/
    where: ClienteWhereUniqueInput
  }


  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs = {
    /**
     * Filter which Clientes to delete
     * 
    **/
    where?: ClienteWhereInput
  }


  /**
   * Cliente without action
   */
  export type ClienteArgs = {
    /**
     * Select specific fields to fetch from the Cliente
     * 
    **/
    select?: ClienteSelect | null
  }



  /**
   * Model Prestador
   */


  export type AggregatePrestador = {
    _count: PrestadorCountAggregateOutputType | null
    _min: PrestadorMinAggregateOutputType | null
    _max: PrestadorMaxAggregateOutputType | null
  }

  export type PrestadorMinAggregateOutputType = {
    CNPJ: string | null
    Nome: string | null
    email: string | null
    Senha: string | null
  }

  export type PrestadorMaxAggregateOutputType = {
    CNPJ: string | null
    Nome: string | null
    email: string | null
    Senha: string | null
  }

  export type PrestadorCountAggregateOutputType = {
    CNPJ: number
    Nome: number
    email: number
    Senha: number
    _all: number
  }


  export type PrestadorMinAggregateInputType = {
    CNPJ?: true
    Nome?: true
    email?: true
    Senha?: true
  }

  export type PrestadorMaxAggregateInputType = {
    CNPJ?: true
    Nome?: true
    email?: true
    Senha?: true
  }

  export type PrestadorCountAggregateInputType = {
    CNPJ?: true
    Nome?: true
    email?: true
    Senha?: true
    _all?: true
  }

  export type PrestadorAggregateArgs = {
    /**
     * Filter which Prestador to aggregate.
     * 
    **/
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     * 
    **/
    orderBy?: Enumerable<PrestadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prestadors
    **/
    _count?: true | PrestadorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrestadorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrestadorMaxAggregateInputType
  }

  export type GetPrestadorAggregateType<T extends PrestadorAggregateArgs> = {
        [P in keyof T & keyof AggregatePrestador]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrestador[P]>
      : GetScalarType<T[P], AggregatePrestador[P]>
  }




  export type PrestadorGroupByArgs = {
    where?: PrestadorWhereInput
    orderBy?: Enumerable<PrestadorOrderByWithAggregationInput>
    by: Array<PrestadorScalarFieldEnum>
    having?: PrestadorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrestadorCountAggregateInputType | true
    _min?: PrestadorMinAggregateInputType
    _max?: PrestadorMaxAggregateInputType
  }


  export type PrestadorGroupByOutputType = {
    CNPJ: string
    Nome: string
    email: string
    Senha: string
    _count: PrestadorCountAggregateOutputType | null
    _min: PrestadorMinAggregateOutputType | null
    _max: PrestadorMaxAggregateOutputType | null
  }

  type GetPrestadorGroupByPayload<T extends PrestadorGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PrestadorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrestadorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrestadorGroupByOutputType[P]>
            : GetScalarType<T[P], PrestadorGroupByOutputType[P]>
        }
      >
    >


  export type PrestadorSelect = {
    CNPJ?: boolean
    Nome?: boolean
    email?: boolean
    Senha?: boolean
    servicos?: boolean | ServicoFindManyArgs
    _count?: boolean | PrestadorCountOutputTypeArgs
  }


  export type PrestadorInclude = {
    servicos?: boolean | ServicoFindManyArgs
    _count?: boolean | PrestadorCountOutputTypeArgs
  } 

  export type PrestadorGetPayload<S extends boolean | null | undefined | PrestadorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Prestador :
    S extends undefined ? never :
    S extends { include: any } & (PrestadorArgs | PrestadorFindManyArgs)
    ? Prestador  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'servicos' ? Array < ServicoGetPayload<S['include'][P]>>  :
        P extends '_count' ? PrestadorCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PrestadorArgs | PrestadorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'servicos' ? Array < ServicoGetPayload<S['select'][P]>>  :
        P extends '_count' ? PrestadorCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Prestador ? Prestador[P] : never
  } 
      : Prestador


  type PrestadorCountArgs = Merge<
    Omit<PrestadorFindManyArgs, 'select' | 'include'> & {
      select?: PrestadorCountAggregateInputType | true
    }
  >

  export interface PrestadorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Prestador that matches the filter.
     * @param {PrestadorFindUniqueArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PrestadorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PrestadorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Prestador'> extends True ? Prisma__PrestadorClient<PrestadorGetPayload<T>> : Prisma__PrestadorClient<PrestadorGetPayload<T> | null, null>

    /**
     * Find one Prestador that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PrestadorFindUniqueOrThrowArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PrestadorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PrestadorFindUniqueOrThrowArgs>
    ): Prisma__PrestadorClient<PrestadorGetPayload<T>>

    /**
     * Find the first Prestador that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindFirstArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PrestadorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PrestadorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Prestador'> extends True ? Prisma__PrestadorClient<PrestadorGetPayload<T>> : Prisma__PrestadorClient<PrestadorGetPayload<T> | null, null>

    /**
     * Find the first Prestador that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindFirstOrThrowArgs} args - Arguments to find a Prestador
     * @example
     * // Get one Prestador
     * const prestador = await prisma.prestador.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PrestadorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PrestadorFindFirstOrThrowArgs>
    ): Prisma__PrestadorClient<PrestadorGetPayload<T>>

    /**
     * Find zero or more Prestadors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prestadors
     * const prestadors = await prisma.prestador.findMany()
     * 
     * // Get first 10 Prestadors
     * const prestadors = await prisma.prestador.findMany({ take: 10 })
     * 
     * // Only select the `CNPJ`
     * const prestadorWithCNPJOnly = await prisma.prestador.findMany({ select: { CNPJ: true } })
     * 
    **/
    findMany<T extends PrestadorFindManyArgs>(
      args?: SelectSubset<T, PrestadorFindManyArgs>
    ): PrismaPromise<Array<PrestadorGetPayload<T>>>

    /**
     * Create a Prestador.
     * @param {PrestadorCreateArgs} args - Arguments to create a Prestador.
     * @example
     * // Create one Prestador
     * const Prestador = await prisma.prestador.create({
     *   data: {
     *     // ... data to create a Prestador
     *   }
     * })
     * 
    **/
    create<T extends PrestadorCreateArgs>(
      args: SelectSubset<T, PrestadorCreateArgs>
    ): Prisma__PrestadorClient<PrestadorGetPayload<T>>

    /**
     * Create many Prestadors.
     *     @param {PrestadorCreateManyArgs} args - Arguments to create many Prestadors.
     *     @example
     *     // Create many Prestadors
     *     const prestador = await prisma.prestador.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PrestadorCreateManyArgs>(
      args?: SelectSubset<T, PrestadorCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Prestador.
     * @param {PrestadorDeleteArgs} args - Arguments to delete one Prestador.
     * @example
     * // Delete one Prestador
     * const Prestador = await prisma.prestador.delete({
     *   where: {
     *     // ... filter to delete one Prestador
     *   }
     * })
     * 
    **/
    delete<T extends PrestadorDeleteArgs>(
      args: SelectSubset<T, PrestadorDeleteArgs>
    ): Prisma__PrestadorClient<PrestadorGetPayload<T>>

    /**
     * Update one Prestador.
     * @param {PrestadorUpdateArgs} args - Arguments to update one Prestador.
     * @example
     * // Update one Prestador
     * const prestador = await prisma.prestador.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PrestadorUpdateArgs>(
      args: SelectSubset<T, PrestadorUpdateArgs>
    ): Prisma__PrestadorClient<PrestadorGetPayload<T>>

    /**
     * Delete zero or more Prestadors.
     * @param {PrestadorDeleteManyArgs} args - Arguments to filter Prestadors to delete.
     * @example
     * // Delete a few Prestadors
     * const { count } = await prisma.prestador.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PrestadorDeleteManyArgs>(
      args?: SelectSubset<T, PrestadorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prestadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prestadors
     * const prestador = await prisma.prestador.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PrestadorUpdateManyArgs>(
      args: SelectSubset<T, PrestadorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Prestador.
     * @param {PrestadorUpsertArgs} args - Arguments to update or create a Prestador.
     * @example
     * // Update or create a Prestador
     * const prestador = await prisma.prestador.upsert({
     *   create: {
     *     // ... data to create a Prestador
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prestador we want to update
     *   }
     * })
    **/
    upsert<T extends PrestadorUpsertArgs>(
      args: SelectSubset<T, PrestadorUpsertArgs>
    ): Prisma__PrestadorClient<PrestadorGetPayload<T>>

    /**
     * Count the number of Prestadors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorCountArgs} args - Arguments to filter Prestadors to count.
     * @example
     * // Count the number of Prestadors
     * const count = await prisma.prestador.count({
     *   where: {
     *     // ... the filter for the Prestadors we want to count
     *   }
     * })
    **/
    count<T extends PrestadorCountArgs>(
      args?: Subset<T, PrestadorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrestadorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prestador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrestadorAggregateArgs>(args: Subset<T, PrestadorAggregateArgs>): PrismaPromise<GetPrestadorAggregateType<T>>

    /**
     * Group by Prestador.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrestadorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrestadorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrestadorGroupByArgs['orderBy'] }
        : { orderBy?: PrestadorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrestadorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrestadorGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Prestador.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PrestadorClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    servicos<T extends ServicoFindManyArgs= {}>(args?: Subset<T, ServicoFindManyArgs>): PrismaPromise<Array<ServicoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Prestador base type for findUnique actions
   */
  export type PrestadorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
    /**
     * Filter, which Prestador to fetch.
     * 
    **/
    where: PrestadorWhereUniqueInput
  }

  /**
   * Prestador: findUnique
   */
  export interface PrestadorFindUniqueArgs extends PrestadorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prestador findUniqueOrThrow
   */
  export type PrestadorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
    /**
     * Filter, which Prestador to fetch.
     * 
    **/
    where: PrestadorWhereUniqueInput
  }


  /**
   * Prestador base type for findFirst actions
   */
  export type PrestadorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
    /**
     * Filter, which Prestador to fetch.
     * 
    **/
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     * 
    **/
    orderBy?: Enumerable<PrestadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prestadors.
     * 
    **/
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prestadors.
     * 
    **/
    distinct?: Enumerable<PrestadorScalarFieldEnum>
  }

  /**
   * Prestador: findFirst
   */
  export interface PrestadorFindFirstArgs extends PrestadorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Prestador findFirstOrThrow
   */
  export type PrestadorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
    /**
     * Filter, which Prestador to fetch.
     * 
    **/
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     * 
    **/
    orderBy?: Enumerable<PrestadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prestadors.
     * 
    **/
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prestadors.
     * 
    **/
    distinct?: Enumerable<PrestadorScalarFieldEnum>
  }


  /**
   * Prestador findMany
   */
  export type PrestadorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
    /**
     * Filter, which Prestadors to fetch.
     * 
    **/
    where?: PrestadorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prestadors to fetch.
     * 
    **/
    orderBy?: Enumerable<PrestadorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prestadors.
     * 
    **/
    cursor?: PrestadorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prestadors from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prestadors.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PrestadorScalarFieldEnum>
  }


  /**
   * Prestador create
   */
  export type PrestadorCreateArgs = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
    /**
     * The data needed to create a Prestador.
     * 
    **/
    data: XOR<PrestadorCreateInput, PrestadorUncheckedCreateInput>
  }


  /**
   * Prestador createMany
   */
  export type PrestadorCreateManyArgs = {
    /**
     * The data used to create many Prestadors.
     * 
    **/
    data: Enumerable<PrestadorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Prestador update
   */
  export type PrestadorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
    /**
     * The data needed to update a Prestador.
     * 
    **/
    data: XOR<PrestadorUpdateInput, PrestadorUncheckedUpdateInput>
    /**
     * Choose, which Prestador to update.
     * 
    **/
    where: PrestadorWhereUniqueInput
  }


  /**
   * Prestador updateMany
   */
  export type PrestadorUpdateManyArgs = {
    /**
     * The data used to update Prestadors.
     * 
    **/
    data: XOR<PrestadorUpdateManyMutationInput, PrestadorUncheckedUpdateManyInput>
    /**
     * Filter which Prestadors to update
     * 
    **/
    where?: PrestadorWhereInput
  }


  /**
   * Prestador upsert
   */
  export type PrestadorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
    /**
     * The filter to search for the Prestador to update in case it exists.
     * 
    **/
    where: PrestadorWhereUniqueInput
    /**
     * In case the Prestador found by the `where` argument doesn't exist, create a new Prestador with this data.
     * 
    **/
    create: XOR<PrestadorCreateInput, PrestadorUncheckedCreateInput>
    /**
     * In case the Prestador was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PrestadorUpdateInput, PrestadorUncheckedUpdateInput>
  }


  /**
   * Prestador delete
   */
  export type PrestadorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
    /**
     * Filter which Prestador to delete.
     * 
    **/
    where: PrestadorWhereUniqueInput
  }


  /**
   * Prestador deleteMany
   */
  export type PrestadorDeleteManyArgs = {
    /**
     * Filter which Prestadors to delete
     * 
    **/
    where?: PrestadorWhereInput
  }


  /**
   * Prestador without action
   */
  export type PrestadorArgs = {
    /**
     * Select specific fields to fetch from the Prestador
     * 
    **/
    select?: PrestadorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrestadorInclude | null
  }



  /**
   * Model Servico
   */


  export type AggregateServico = {
    _count: ServicoCountAggregateOutputType | null
    _avg: ServicoAvgAggregateOutputType | null
    _sum: ServicoSumAggregateOutputType | null
    _min: ServicoMinAggregateOutputType | null
    _max: ServicoMaxAggregateOutputType | null
  }

  export type ServicoAvgAggregateOutputType = {
    preco: number | null
  }

  export type ServicoSumAggregateOutputType = {
    preco: number | null
  }

  export type ServicoMinAggregateOutputType = {
    id: string | null
    NomeServico: string | null
    preco: number | null
    descricao: string | null
    img: string | null
    servicoId: string | null
  }

  export type ServicoMaxAggregateOutputType = {
    id: string | null
    NomeServico: string | null
    preco: number | null
    descricao: string | null
    img: string | null
    servicoId: string | null
  }

  export type ServicoCountAggregateOutputType = {
    id: number
    NomeServico: number
    preco: number
    descricao: number
    img: number
    servicoId: number
    _all: number
  }


  export type ServicoAvgAggregateInputType = {
    preco?: true
  }

  export type ServicoSumAggregateInputType = {
    preco?: true
  }

  export type ServicoMinAggregateInputType = {
    id?: true
    NomeServico?: true
    preco?: true
    descricao?: true
    img?: true
    servicoId?: true
  }

  export type ServicoMaxAggregateInputType = {
    id?: true
    NomeServico?: true
    preco?: true
    descricao?: true
    img?: true
    servicoId?: true
  }

  export type ServicoCountAggregateInputType = {
    id?: true
    NomeServico?: true
    preco?: true
    descricao?: true
    img?: true
    servicoId?: true
    _all?: true
  }

  export type ServicoAggregateArgs = {
    /**
     * Filter which Servico to aggregate.
     * 
    **/
    where?: ServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicos to fetch.
     * 
    **/
    orderBy?: Enumerable<ServicoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servicos
    **/
    _count?: true | ServicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicoMaxAggregateInputType
  }

  export type GetServicoAggregateType<T extends ServicoAggregateArgs> = {
        [P in keyof T & keyof AggregateServico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServico[P]>
      : GetScalarType<T[P], AggregateServico[P]>
  }




  export type ServicoGroupByArgs = {
    where?: ServicoWhereInput
    orderBy?: Enumerable<ServicoOrderByWithAggregationInput>
    by: Array<ServicoScalarFieldEnum>
    having?: ServicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicoCountAggregateInputType | true
    _avg?: ServicoAvgAggregateInputType
    _sum?: ServicoSumAggregateInputType
    _min?: ServicoMinAggregateInputType
    _max?: ServicoMaxAggregateInputType
  }


  export type ServicoGroupByOutputType = {
    id: string
    NomeServico: string
    preco: number
    descricao: string
    img: string
    servicoId: string
    _count: ServicoCountAggregateOutputType | null
    _avg: ServicoAvgAggregateOutputType | null
    _sum: ServicoSumAggregateOutputType | null
    _min: ServicoMinAggregateOutputType | null
    _max: ServicoMaxAggregateOutputType | null
  }

  type GetServicoGroupByPayload<T extends ServicoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ServicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicoGroupByOutputType[P]>
            : GetScalarType<T[P], ServicoGroupByOutputType[P]>
        }
      >
    >


  export type ServicoSelect = {
    id?: boolean
    NomeServico?: boolean
    preco?: boolean
    descricao?: boolean
    img?: boolean
    servicoId?: boolean
    prestador?: boolean | PrestadorArgs
    categoria?: boolean | CategoriaFindManyArgs
    _count?: boolean | ServicoCountOutputTypeArgs
  }


  export type ServicoInclude = {
    prestador?: boolean | PrestadorArgs
    categoria?: boolean | CategoriaFindManyArgs
    _count?: boolean | ServicoCountOutputTypeArgs
  } 

  export type ServicoGetPayload<S extends boolean | null | undefined | ServicoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Servico :
    S extends undefined ? never :
    S extends { include: any } & (ServicoArgs | ServicoFindManyArgs)
    ? Servico  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'prestador' ? PrestadorGetPayload<S['include'][P]> :
        P extends 'categoria' ? Array < CategoriaGetPayload<S['include'][P]>>  :
        P extends '_count' ? ServicoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ServicoArgs | ServicoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'prestador' ? PrestadorGetPayload<S['select'][P]> :
        P extends 'categoria' ? Array < CategoriaGetPayload<S['select'][P]>>  :
        P extends '_count' ? ServicoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Servico ? Servico[P] : never
  } 
      : Servico


  type ServicoCountArgs = Merge<
    Omit<ServicoFindManyArgs, 'select' | 'include'> & {
      select?: ServicoCountAggregateInputType | true
    }
  >

  export interface ServicoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Servico that matches the filter.
     * @param {ServicoFindUniqueArgs} args - Arguments to find a Servico
     * @example
     * // Get one Servico
     * const servico = await prisma.servico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServicoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServicoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Servico'> extends True ? Prisma__ServicoClient<ServicoGetPayload<T>> : Prisma__ServicoClient<ServicoGetPayload<T> | null, null>

    /**
     * Find one Servico that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServicoFindUniqueOrThrowArgs} args - Arguments to find a Servico
     * @example
     * // Get one Servico
     * const servico = await prisma.servico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServicoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ServicoFindUniqueOrThrowArgs>
    ): Prisma__ServicoClient<ServicoGetPayload<T>>

    /**
     * Find the first Servico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoFindFirstArgs} args - Arguments to find a Servico
     * @example
     * // Get one Servico
     * const servico = await prisma.servico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServicoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServicoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Servico'> extends True ? Prisma__ServicoClient<ServicoGetPayload<T>> : Prisma__ServicoClient<ServicoGetPayload<T> | null, null>

    /**
     * Find the first Servico that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoFindFirstOrThrowArgs} args - Arguments to find a Servico
     * @example
     * // Get one Servico
     * const servico = await prisma.servico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServicoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServicoFindFirstOrThrowArgs>
    ): Prisma__ServicoClient<ServicoGetPayload<T>>

    /**
     * Find zero or more Servicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicos
     * const servicos = await prisma.servico.findMany()
     * 
     * // Get first 10 Servicos
     * const servicos = await prisma.servico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicoWithIdOnly = await prisma.servico.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServicoFindManyArgs>(
      args?: SelectSubset<T, ServicoFindManyArgs>
    ): PrismaPromise<Array<ServicoGetPayload<T>>>

    /**
     * Create a Servico.
     * @param {ServicoCreateArgs} args - Arguments to create a Servico.
     * @example
     * // Create one Servico
     * const Servico = await prisma.servico.create({
     *   data: {
     *     // ... data to create a Servico
     *   }
     * })
     * 
    **/
    create<T extends ServicoCreateArgs>(
      args: SelectSubset<T, ServicoCreateArgs>
    ): Prisma__ServicoClient<ServicoGetPayload<T>>

    /**
     * Create many Servicos.
     *     @param {ServicoCreateManyArgs} args - Arguments to create many Servicos.
     *     @example
     *     // Create many Servicos
     *     const servico = await prisma.servico.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServicoCreateManyArgs>(
      args?: SelectSubset<T, ServicoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Servico.
     * @param {ServicoDeleteArgs} args - Arguments to delete one Servico.
     * @example
     * // Delete one Servico
     * const Servico = await prisma.servico.delete({
     *   where: {
     *     // ... filter to delete one Servico
     *   }
     * })
     * 
    **/
    delete<T extends ServicoDeleteArgs>(
      args: SelectSubset<T, ServicoDeleteArgs>
    ): Prisma__ServicoClient<ServicoGetPayload<T>>

    /**
     * Update one Servico.
     * @param {ServicoUpdateArgs} args - Arguments to update one Servico.
     * @example
     * // Update one Servico
     * const servico = await prisma.servico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServicoUpdateArgs>(
      args: SelectSubset<T, ServicoUpdateArgs>
    ): Prisma__ServicoClient<ServicoGetPayload<T>>

    /**
     * Delete zero or more Servicos.
     * @param {ServicoDeleteManyArgs} args - Arguments to filter Servicos to delete.
     * @example
     * // Delete a few Servicos
     * const { count } = await prisma.servico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServicoDeleteManyArgs>(
      args?: SelectSubset<T, ServicoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicos
     * const servico = await prisma.servico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServicoUpdateManyArgs>(
      args: SelectSubset<T, ServicoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Servico.
     * @param {ServicoUpsertArgs} args - Arguments to update or create a Servico.
     * @example
     * // Update or create a Servico
     * const servico = await prisma.servico.upsert({
     *   create: {
     *     // ... data to create a Servico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servico we want to update
     *   }
     * })
    **/
    upsert<T extends ServicoUpsertArgs>(
      args: SelectSubset<T, ServicoUpsertArgs>
    ): Prisma__ServicoClient<ServicoGetPayload<T>>

    /**
     * Count the number of Servicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoCountArgs} args - Arguments to filter Servicos to count.
     * @example
     * // Count the number of Servicos
     * const count = await prisma.servico.count({
     *   where: {
     *     // ... the filter for the Servicos we want to count
     *   }
     * })
    **/
    count<T extends ServicoCountArgs>(
      args?: Subset<T, ServicoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicoAggregateArgs>(args: Subset<T, ServicoAggregateArgs>): PrismaPromise<GetServicoAggregateType<T>>

    /**
     * Group by Servico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicoGroupByArgs['orderBy'] }
        : { orderBy?: ServicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Servico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServicoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    prestador<T extends PrestadorArgs= {}>(args?: Subset<T, PrestadorArgs>): Prisma__PrestadorClient<PrestadorGetPayload<T> | Null>;

    categoria<T extends CategoriaFindManyArgs= {}>(args?: Subset<T, CategoriaFindManyArgs>): PrismaPromise<Array<CategoriaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Servico base type for findUnique actions
   */
  export type ServicoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
    /**
     * Filter, which Servico to fetch.
     * 
    **/
    where: ServicoWhereUniqueInput
  }

  /**
   * Servico: findUnique
   */
  export interface ServicoFindUniqueArgs extends ServicoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Servico findUniqueOrThrow
   */
  export type ServicoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
    /**
     * Filter, which Servico to fetch.
     * 
    **/
    where: ServicoWhereUniqueInput
  }


  /**
   * Servico base type for findFirst actions
   */
  export type ServicoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
    /**
     * Filter, which Servico to fetch.
     * 
    **/
    where?: ServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicos to fetch.
     * 
    **/
    orderBy?: Enumerable<ServicoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicos.
     * 
    **/
    cursor?: ServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicos.
     * 
    **/
    distinct?: Enumerable<ServicoScalarFieldEnum>
  }

  /**
   * Servico: findFirst
   */
  export interface ServicoFindFirstArgs extends ServicoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Servico findFirstOrThrow
   */
  export type ServicoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
    /**
     * Filter, which Servico to fetch.
     * 
    **/
    where?: ServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicos to fetch.
     * 
    **/
    orderBy?: Enumerable<ServicoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicos.
     * 
    **/
    cursor?: ServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicos.
     * 
    **/
    distinct?: Enumerable<ServicoScalarFieldEnum>
  }


  /**
   * Servico findMany
   */
  export type ServicoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
    /**
     * Filter, which Servicos to fetch.
     * 
    **/
    where?: ServicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicos to fetch.
     * 
    **/
    orderBy?: Enumerable<ServicoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servicos.
     * 
    **/
    cursor?: ServicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ServicoScalarFieldEnum>
  }


  /**
   * Servico create
   */
  export type ServicoCreateArgs = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
    /**
     * The data needed to create a Servico.
     * 
    **/
    data: XOR<ServicoCreateInput, ServicoUncheckedCreateInput>
  }


  /**
   * Servico createMany
   */
  export type ServicoCreateManyArgs = {
    /**
     * The data used to create many Servicos.
     * 
    **/
    data: Enumerable<ServicoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Servico update
   */
  export type ServicoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
    /**
     * The data needed to update a Servico.
     * 
    **/
    data: XOR<ServicoUpdateInput, ServicoUncheckedUpdateInput>
    /**
     * Choose, which Servico to update.
     * 
    **/
    where: ServicoWhereUniqueInput
  }


  /**
   * Servico updateMany
   */
  export type ServicoUpdateManyArgs = {
    /**
     * The data used to update Servicos.
     * 
    **/
    data: XOR<ServicoUpdateManyMutationInput, ServicoUncheckedUpdateManyInput>
    /**
     * Filter which Servicos to update
     * 
    **/
    where?: ServicoWhereInput
  }


  /**
   * Servico upsert
   */
  export type ServicoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
    /**
     * The filter to search for the Servico to update in case it exists.
     * 
    **/
    where: ServicoWhereUniqueInput
    /**
     * In case the Servico found by the `where` argument doesn't exist, create a new Servico with this data.
     * 
    **/
    create: XOR<ServicoCreateInput, ServicoUncheckedCreateInput>
    /**
     * In case the Servico was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ServicoUpdateInput, ServicoUncheckedUpdateInput>
  }


  /**
   * Servico delete
   */
  export type ServicoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
    /**
     * Filter which Servico to delete.
     * 
    **/
    where: ServicoWhereUniqueInput
  }


  /**
   * Servico deleteMany
   */
  export type ServicoDeleteManyArgs = {
    /**
     * Filter which Servicos to delete
     * 
    **/
    where?: ServicoWhereInput
  }


  /**
   * Servico without action
   */
  export type ServicoArgs = {
    /**
     * Select specific fields to fetch from the Servico
     * 
    **/
    select?: ServicoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServicoInclude | null
  }



  /**
   * Model Categoria
   */


  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: string | null
    nomeCategoria: string | null
    descricao: string | null
    servicoId: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: string | null
    nomeCategoria: string | null
    descricao: string | null
    servicoId: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    nomeCategoria: number
    descricao: number
    servicoId: number
    _all: number
  }


  export type CategoriaMinAggregateInputType = {
    id?: true
    nomeCategoria?: true
    descricao?: true
    servicoId?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    nomeCategoria?: true
    descricao?: true
    servicoId?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    nomeCategoria?: true
    descricao?: true
    servicoId?: true
    _all?: true
  }

  export type CategoriaAggregateArgs = {
    /**
     * Filter which Categoria to aggregate.
     * 
    **/
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs = {
    where?: CategoriaWhereInput
    orderBy?: Enumerable<CategoriaOrderByWithAggregationInput>
    by: Array<CategoriaScalarFieldEnum>
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }


  export type CategoriaGroupByOutputType = {
    id: string
    nomeCategoria: string
    descricao: string
    servicoId: string | null
    _count: CategoriaCountAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect = {
    id?: boolean
    nomeCategoria?: boolean
    descricao?: boolean
    servicoId?: boolean
    servico?: boolean | ServicoArgs
  }


  export type CategoriaInclude = {
    servico?: boolean | ServicoArgs
  } 

  export type CategoriaGetPayload<S extends boolean | null | undefined | CategoriaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Categoria :
    S extends undefined ? never :
    S extends { include: any } & (CategoriaArgs | CategoriaFindManyArgs)
    ? Categoria  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'servico' ? ServicoGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (CategoriaArgs | CategoriaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'servico' ? ServicoGetPayload<S['select'][P]> | null :  P extends keyof Categoria ? Categoria[P] : never
  } 
      : Categoria


  type CategoriaCountArgs = Merge<
    Omit<CategoriaFindManyArgs, 'select' | 'include'> & {
      select?: CategoriaCountAggregateInputType | true
    }
  >

  export interface CategoriaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoriaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoriaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Categoria'> extends True ? Prisma__CategoriaClient<CategoriaGetPayload<T>> : Prisma__CategoriaClient<CategoriaGetPayload<T> | null, null>

    /**
     * Find one Categoria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoriaFindUniqueOrThrowArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoriaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoriaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Categoria'> extends True ? Prisma__CategoriaClient<CategoriaGetPayload<T>> : Prisma__CategoriaClient<CategoriaGetPayload<T> | null, null>

    /**
     * Find the first Categoria that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoriaFindManyArgs>(
      args?: SelectSubset<T, CategoriaFindManyArgs>
    ): PrismaPromise<Array<CategoriaGetPayload<T>>>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
    **/
    create<T extends CategoriaCreateArgs>(
      args: SelectSubset<T, CategoriaCreateArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Create many Categorias.
     *     @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     *     @example
     *     // Create many Categorias
     *     const categoria = await prisma.categoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoriaCreateManyArgs>(
      args?: SelectSubset<T, CategoriaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
    **/
    delete<T extends CategoriaDeleteArgs>(
      args: SelectSubset<T, CategoriaDeleteArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoriaUpdateArgs>(
      args: SelectSubset<T, CategoriaUpdateArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoriaDeleteManyArgs>(
      args?: SelectSubset<T, CategoriaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoriaUpdateManyArgs>(
      args: SelectSubset<T, CategoriaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
    **/
    upsert<T extends CategoriaUpsertArgs>(
      args: SelectSubset<T, CategoriaUpsertArgs>
    ): Prisma__CategoriaClient<CategoriaGetPayload<T>>

    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoriaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    servico<T extends ServicoArgs= {}>(args?: Subset<T, ServicoArgs>): Prisma__ServicoClient<ServicoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Categoria base type for findUnique actions
   */
  export type CategoriaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Filter, which Categoria to fetch.
     * 
    **/
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria: findUnique
   */
  export interface CategoriaFindUniqueArgs extends CategoriaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Filter, which Categoria to fetch.
     * 
    **/
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria base type for findFirst actions
   */
  export type CategoriaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Filter, which Categoria to fetch.
     * 
    **/
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     * 
    **/
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     * 
    **/
    distinct?: Enumerable<CategoriaScalarFieldEnum>
  }

  /**
   * Categoria: findFirst
   */
  export interface CategoriaFindFirstArgs extends CategoriaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Filter, which Categoria to fetch.
     * 
    **/
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     * 
    **/
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     * 
    **/
    distinct?: Enumerable<CategoriaScalarFieldEnum>
  }


  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Filter, which Categorias to fetch.
     * 
    **/
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     * 
    **/
    orderBy?: Enumerable<CategoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     * 
    **/
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CategoriaScalarFieldEnum>
  }


  /**
   * Categoria create
   */
  export type CategoriaCreateArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * The data needed to create a Categoria.
     * 
    **/
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }


  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs = {
    /**
     * The data used to create many Categorias.
     * 
    **/
    data: Enumerable<CategoriaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * The data needed to update a Categoria.
     * 
    **/
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     * 
    **/
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs = {
    /**
     * The data used to update Categorias.
     * 
    **/
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     * 
    **/
    where?: CategoriaWhereInput
  }


  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     * 
    **/
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     * 
    **/
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }


  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
    /**
     * Filter which Categoria to delete.
     * 
    **/
    where: CategoriaWhereUniqueInput
  }


  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs = {
    /**
     * Filter which Categorias to delete
     * 
    **/
    where?: CategoriaWhereInput
  }


  /**
   * Categoria without action
   */
  export type CategoriaArgs = {
    /**
     * Select specific fields to fetch from the Categoria
     * 
    **/
    select?: CategoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CategoriaInclude | null
  }



  /**
   * Model Agenda
   */


  export type AggregateAgenda = {
    _count: AgendaCountAggregateOutputType | null
    _min: AgendaMinAggregateOutputType | null
    _max: AgendaMaxAggregateOutputType | null
  }

  export type AgendaMinAggregateOutputType = {
    id: string | null
    horario: Date | null
    dia: Date | null
    agendaId: string | null
  }

  export type AgendaMaxAggregateOutputType = {
    id: string | null
    horario: Date | null
    dia: Date | null
    agendaId: string | null
  }

  export type AgendaCountAggregateOutputType = {
    id: number
    horario: number
    dia: number
    agendaId: number
    _all: number
  }


  export type AgendaMinAggregateInputType = {
    id?: true
    horario?: true
    dia?: true
    agendaId?: true
  }

  export type AgendaMaxAggregateInputType = {
    id?: true
    horario?: true
    dia?: true
    agendaId?: true
  }

  export type AgendaCountAggregateInputType = {
    id?: true
    horario?: true
    dia?: true
    agendaId?: true
    _all?: true
  }

  export type AgendaAggregateArgs = {
    /**
     * Filter which Agenda to aggregate.
     * 
    **/
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agenda
    **/
    _count?: true | AgendaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaMaxAggregateInputType
  }

  export type GetAgendaAggregateType<T extends AgendaAggregateArgs> = {
        [P in keyof T & keyof AggregateAgenda]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgenda[P]>
      : GetScalarType<T[P], AggregateAgenda[P]>
  }




  export type AgendaGroupByArgs = {
    where?: AgendaWhereInput
    orderBy?: Enumerable<AgendaOrderByWithAggregationInput>
    by: Array<AgendaScalarFieldEnum>
    having?: AgendaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaCountAggregateInputType | true
    _min?: AgendaMinAggregateInputType
    _max?: AgendaMaxAggregateInputType
  }


  export type AgendaGroupByOutputType = {
    id: string
    horario: Date
    dia: Date
    agendaId: string
    _count: AgendaCountAggregateOutputType | null
    _min: AgendaMinAggregateOutputType | null
    _max: AgendaMaxAggregateOutputType | null
  }

  type GetAgendaGroupByPayload<T extends AgendaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AgendaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaGroupByOutputType[P]>
        }
      >
    >


  export type AgendaSelect = {
    id?: boolean
    horario?: boolean
    dia?: boolean
    agendaId?: boolean
    agendado?: boolean | AgendadoArgs
  }


  export type AgendaInclude = {
    agendado?: boolean | AgendadoArgs
  } 

  export type AgendaGetPayload<S extends boolean | null | undefined | AgendaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Agenda :
    S extends undefined ? never :
    S extends { include: any } & (AgendaArgs | AgendaFindManyArgs)
    ? Agenda  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'agendado' ? AgendadoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AgendaArgs | AgendaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'agendado' ? AgendadoGetPayload<S['select'][P]> :  P extends keyof Agenda ? Agenda[P] : never
  } 
      : Agenda


  type AgendaCountArgs = Merge<
    Omit<AgendaFindManyArgs, 'select' | 'include'> & {
      select?: AgendaCountAggregateInputType | true
    }
  >

  export interface AgendaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Agenda that matches the filter.
     * @param {AgendaFindUniqueArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgendaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgendaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Agenda'> extends True ? Prisma__AgendaClient<AgendaGetPayload<T>> : Prisma__AgendaClient<AgendaGetPayload<T> | null, null>

    /**
     * Find one Agenda that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgendaFindUniqueOrThrowArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgendaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AgendaFindUniqueOrThrowArgs>
    ): Prisma__AgendaClient<AgendaGetPayload<T>>

    /**
     * Find the first Agenda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaFindFirstArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgendaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgendaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Agenda'> extends True ? Prisma__AgendaClient<AgendaGetPayload<T>> : Prisma__AgendaClient<AgendaGetPayload<T> | null, null>

    /**
     * Find the first Agenda that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaFindFirstOrThrowArgs} args - Arguments to find a Agenda
     * @example
     * // Get one Agenda
     * const agenda = await prisma.agenda.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgendaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AgendaFindFirstOrThrowArgs>
    ): Prisma__AgendaClient<AgendaGetPayload<T>>

    /**
     * Find zero or more Agenda that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agenda
     * const agenda = await prisma.agenda.findMany()
     * 
     * // Get first 10 Agenda
     * const agenda = await prisma.agenda.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaWithIdOnly = await prisma.agenda.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgendaFindManyArgs>(
      args?: SelectSubset<T, AgendaFindManyArgs>
    ): PrismaPromise<Array<AgendaGetPayload<T>>>

    /**
     * Create a Agenda.
     * @param {AgendaCreateArgs} args - Arguments to create a Agenda.
     * @example
     * // Create one Agenda
     * const Agenda = await prisma.agenda.create({
     *   data: {
     *     // ... data to create a Agenda
     *   }
     * })
     * 
    **/
    create<T extends AgendaCreateArgs>(
      args: SelectSubset<T, AgendaCreateArgs>
    ): Prisma__AgendaClient<AgendaGetPayload<T>>

    /**
     * Create many Agenda.
     *     @param {AgendaCreateManyArgs} args - Arguments to create many Agenda.
     *     @example
     *     // Create many Agenda
     *     const agenda = await prisma.agenda.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgendaCreateManyArgs>(
      args?: SelectSubset<T, AgendaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Agenda.
     * @param {AgendaDeleteArgs} args - Arguments to delete one Agenda.
     * @example
     * // Delete one Agenda
     * const Agenda = await prisma.agenda.delete({
     *   where: {
     *     // ... filter to delete one Agenda
     *   }
     * })
     * 
    **/
    delete<T extends AgendaDeleteArgs>(
      args: SelectSubset<T, AgendaDeleteArgs>
    ): Prisma__AgendaClient<AgendaGetPayload<T>>

    /**
     * Update one Agenda.
     * @param {AgendaUpdateArgs} args - Arguments to update one Agenda.
     * @example
     * // Update one Agenda
     * const agenda = await prisma.agenda.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgendaUpdateArgs>(
      args: SelectSubset<T, AgendaUpdateArgs>
    ): Prisma__AgendaClient<AgendaGetPayload<T>>

    /**
     * Delete zero or more Agenda.
     * @param {AgendaDeleteManyArgs} args - Arguments to filter Agenda to delete.
     * @example
     * // Delete a few Agenda
     * const { count } = await prisma.agenda.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgendaDeleteManyArgs>(
      args?: SelectSubset<T, AgendaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agenda
     * const agenda = await prisma.agenda.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgendaUpdateManyArgs>(
      args: SelectSubset<T, AgendaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Agenda.
     * @param {AgendaUpsertArgs} args - Arguments to update or create a Agenda.
     * @example
     * // Update or create a Agenda
     * const agenda = await prisma.agenda.upsert({
     *   create: {
     *     // ... data to create a Agenda
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agenda we want to update
     *   }
     * })
    **/
    upsert<T extends AgendaUpsertArgs>(
      args: SelectSubset<T, AgendaUpsertArgs>
    ): Prisma__AgendaClient<AgendaGetPayload<T>>

    /**
     * Count the number of Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaCountArgs} args - Arguments to filter Agenda to count.
     * @example
     * // Count the number of Agenda
     * const count = await prisma.agenda.count({
     *   where: {
     *     // ... the filter for the Agenda we want to count
     *   }
     * })
    **/
    count<T extends AgendaCountArgs>(
      args?: Subset<T, AgendaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaAggregateArgs>(args: Subset<T, AgendaAggregateArgs>): PrismaPromise<GetAgendaAggregateType<T>>

    /**
     * Group by Agenda.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaGroupByArgs['orderBy'] }
        : { orderBy?: AgendaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Agenda.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgendaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    agendado<T extends AgendadoArgs= {}>(args?: Subset<T, AgendadoArgs>): Prisma__AgendadoClient<AgendadoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Agenda base type for findUnique actions
   */
  export type AgendaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
    /**
     * Filter, which Agenda to fetch.
     * 
    **/
    where: AgendaWhereUniqueInput
  }

  /**
   * Agenda: findUnique
   */
  export interface AgendaFindUniqueArgs extends AgendaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Agenda findUniqueOrThrow
   */
  export type AgendaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
    /**
     * Filter, which Agenda to fetch.
     * 
    **/
    where: AgendaWhereUniqueInput
  }


  /**
   * Agenda base type for findFirst actions
   */
  export type AgendaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
    /**
     * Filter, which Agenda to fetch.
     * 
    **/
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agenda.
     * 
    **/
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agenda.
     * 
    **/
    distinct?: Enumerable<AgendaScalarFieldEnum>
  }

  /**
   * Agenda: findFirst
   */
  export interface AgendaFindFirstArgs extends AgendaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Agenda findFirstOrThrow
   */
  export type AgendaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
    /**
     * Filter, which Agenda to fetch.
     * 
    **/
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agenda.
     * 
    **/
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agenda.
     * 
    **/
    distinct?: Enumerable<AgendaScalarFieldEnum>
  }


  /**
   * Agenda findMany
   */
  export type AgendaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
    /**
     * Filter, which Agenda to fetch.
     * 
    **/
    where?: AgendaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agenda to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agenda.
     * 
    **/
    cursor?: AgendaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agenda from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agenda.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AgendaScalarFieldEnum>
  }


  /**
   * Agenda create
   */
  export type AgendaCreateArgs = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
    /**
     * The data needed to create a Agenda.
     * 
    **/
    data: XOR<AgendaCreateInput, AgendaUncheckedCreateInput>
  }


  /**
   * Agenda createMany
   */
  export type AgendaCreateManyArgs = {
    /**
     * The data used to create many Agenda.
     * 
    **/
    data: Enumerable<AgendaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Agenda update
   */
  export type AgendaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
    /**
     * The data needed to update a Agenda.
     * 
    **/
    data: XOR<AgendaUpdateInput, AgendaUncheckedUpdateInput>
    /**
     * Choose, which Agenda to update.
     * 
    **/
    where: AgendaWhereUniqueInput
  }


  /**
   * Agenda updateMany
   */
  export type AgendaUpdateManyArgs = {
    /**
     * The data used to update Agenda.
     * 
    **/
    data: XOR<AgendaUpdateManyMutationInput, AgendaUncheckedUpdateManyInput>
    /**
     * Filter which Agenda to update
     * 
    **/
    where?: AgendaWhereInput
  }


  /**
   * Agenda upsert
   */
  export type AgendaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
    /**
     * The filter to search for the Agenda to update in case it exists.
     * 
    **/
    where: AgendaWhereUniqueInput
    /**
     * In case the Agenda found by the `where` argument doesn't exist, create a new Agenda with this data.
     * 
    **/
    create: XOR<AgendaCreateInput, AgendaUncheckedCreateInput>
    /**
     * In case the Agenda was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AgendaUpdateInput, AgendaUncheckedUpdateInput>
  }


  /**
   * Agenda delete
   */
  export type AgendaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
    /**
     * Filter which Agenda to delete.
     * 
    **/
    where: AgendaWhereUniqueInput
  }


  /**
   * Agenda deleteMany
   */
  export type AgendaDeleteManyArgs = {
    /**
     * Filter which Agenda to delete
     * 
    **/
    where?: AgendaWhereInput
  }


  /**
   * Agenda without action
   */
  export type AgendaArgs = {
    /**
     * Select specific fields to fetch from the Agenda
     * 
    **/
    select?: AgendaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaInclude | null
  }



  /**
   * Model AgendaStatus
   */


  export type AggregateAgendaStatus = {
    _count: AgendaStatusCountAggregateOutputType | null
    _min: AgendaStatusMinAggregateOutputType | null
    _max: AgendaStatusMaxAggregateOutputType | null
  }

  export type AgendaStatusMinAggregateOutputType = {
    id: string | null
    nomeStatus: string | null
    descricao: string | null
    statusId: string | null
  }

  export type AgendaStatusMaxAggregateOutputType = {
    id: string | null
    nomeStatus: string | null
    descricao: string | null
    statusId: string | null
  }

  export type AgendaStatusCountAggregateOutputType = {
    id: number
    nomeStatus: number
    descricao: number
    statusId: number
    _all: number
  }


  export type AgendaStatusMinAggregateInputType = {
    id?: true
    nomeStatus?: true
    descricao?: true
    statusId?: true
  }

  export type AgendaStatusMaxAggregateInputType = {
    id?: true
    nomeStatus?: true
    descricao?: true
    statusId?: true
  }

  export type AgendaStatusCountAggregateInputType = {
    id?: true
    nomeStatus?: true
    descricao?: true
    statusId?: true
    _all?: true
  }

  export type AgendaStatusAggregateArgs = {
    /**
     * Filter which AgendaStatus to aggregate.
     * 
    **/
    where?: AgendaStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendaStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AgendaStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgendaStatuses
    **/
    _count?: true | AgendaStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendaStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendaStatusMaxAggregateInputType
  }

  export type GetAgendaStatusAggregateType<T extends AgendaStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendaStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendaStatus[P]>
      : GetScalarType<T[P], AggregateAgendaStatus[P]>
  }




  export type AgendaStatusGroupByArgs = {
    where?: AgendaStatusWhereInput
    orderBy?: Enumerable<AgendaStatusOrderByWithAggregationInput>
    by: Array<AgendaStatusScalarFieldEnum>
    having?: AgendaStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendaStatusCountAggregateInputType | true
    _min?: AgendaStatusMinAggregateInputType
    _max?: AgendaStatusMaxAggregateInputType
  }


  export type AgendaStatusGroupByOutputType = {
    id: string
    nomeStatus: string
    descricao: string
    statusId: string
    _count: AgendaStatusCountAggregateOutputType | null
    _min: AgendaStatusMinAggregateOutputType | null
    _max: AgendaStatusMaxAggregateOutputType | null
  }

  type GetAgendaStatusGroupByPayload<T extends AgendaStatusGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AgendaStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendaStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendaStatusGroupByOutputType[P]>
            : GetScalarType<T[P], AgendaStatusGroupByOutputType[P]>
        }
      >
    >


  export type AgendaStatusSelect = {
    id?: boolean
    nomeStatus?: boolean
    descricao?: boolean
    statusId?: boolean
    agendado?: boolean | AgendadoArgs
  }


  export type AgendaStatusInclude = {
    agendado?: boolean | AgendadoArgs
  } 

  export type AgendaStatusGetPayload<S extends boolean | null | undefined | AgendaStatusArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AgendaStatus :
    S extends undefined ? never :
    S extends { include: any } & (AgendaStatusArgs | AgendaStatusFindManyArgs)
    ? AgendaStatus  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'agendado' ? AgendadoGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AgendaStatusArgs | AgendaStatusFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'agendado' ? AgendadoGetPayload<S['select'][P]> :  P extends keyof AgendaStatus ? AgendaStatus[P] : never
  } 
      : AgendaStatus


  type AgendaStatusCountArgs = Merge<
    Omit<AgendaStatusFindManyArgs, 'select' | 'include'> & {
      select?: AgendaStatusCountAggregateInputType | true
    }
  >

  export interface AgendaStatusDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one AgendaStatus that matches the filter.
     * @param {AgendaStatusFindUniqueArgs} args - Arguments to find a AgendaStatus
     * @example
     * // Get one AgendaStatus
     * const agendaStatus = await prisma.agendaStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgendaStatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgendaStatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AgendaStatus'> extends True ? Prisma__AgendaStatusClient<AgendaStatusGetPayload<T>> : Prisma__AgendaStatusClient<AgendaStatusGetPayload<T> | null, null>

    /**
     * Find one AgendaStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgendaStatusFindUniqueOrThrowArgs} args - Arguments to find a AgendaStatus
     * @example
     * // Get one AgendaStatus
     * const agendaStatus = await prisma.agendaStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgendaStatusFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AgendaStatusFindUniqueOrThrowArgs>
    ): Prisma__AgendaStatusClient<AgendaStatusGetPayload<T>>

    /**
     * Find the first AgendaStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaStatusFindFirstArgs} args - Arguments to find a AgendaStatus
     * @example
     * // Get one AgendaStatus
     * const agendaStatus = await prisma.agendaStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgendaStatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgendaStatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AgendaStatus'> extends True ? Prisma__AgendaStatusClient<AgendaStatusGetPayload<T>> : Prisma__AgendaStatusClient<AgendaStatusGetPayload<T> | null, null>

    /**
     * Find the first AgendaStatus that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaStatusFindFirstOrThrowArgs} args - Arguments to find a AgendaStatus
     * @example
     * // Get one AgendaStatus
     * const agendaStatus = await prisma.agendaStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgendaStatusFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AgendaStatusFindFirstOrThrowArgs>
    ): Prisma__AgendaStatusClient<AgendaStatusGetPayload<T>>

    /**
     * Find zero or more AgendaStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgendaStatuses
     * const agendaStatuses = await prisma.agendaStatus.findMany()
     * 
     * // Get first 10 AgendaStatuses
     * const agendaStatuses = await prisma.agendaStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendaStatusWithIdOnly = await prisma.agendaStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgendaStatusFindManyArgs>(
      args?: SelectSubset<T, AgendaStatusFindManyArgs>
    ): PrismaPromise<Array<AgendaStatusGetPayload<T>>>

    /**
     * Create a AgendaStatus.
     * @param {AgendaStatusCreateArgs} args - Arguments to create a AgendaStatus.
     * @example
     * // Create one AgendaStatus
     * const AgendaStatus = await prisma.agendaStatus.create({
     *   data: {
     *     // ... data to create a AgendaStatus
     *   }
     * })
     * 
    **/
    create<T extends AgendaStatusCreateArgs>(
      args: SelectSubset<T, AgendaStatusCreateArgs>
    ): Prisma__AgendaStatusClient<AgendaStatusGetPayload<T>>

    /**
     * Create many AgendaStatuses.
     *     @param {AgendaStatusCreateManyArgs} args - Arguments to create many AgendaStatuses.
     *     @example
     *     // Create many AgendaStatuses
     *     const agendaStatus = await prisma.agendaStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgendaStatusCreateManyArgs>(
      args?: SelectSubset<T, AgendaStatusCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AgendaStatus.
     * @param {AgendaStatusDeleteArgs} args - Arguments to delete one AgendaStatus.
     * @example
     * // Delete one AgendaStatus
     * const AgendaStatus = await prisma.agendaStatus.delete({
     *   where: {
     *     // ... filter to delete one AgendaStatus
     *   }
     * })
     * 
    **/
    delete<T extends AgendaStatusDeleteArgs>(
      args: SelectSubset<T, AgendaStatusDeleteArgs>
    ): Prisma__AgendaStatusClient<AgendaStatusGetPayload<T>>

    /**
     * Update one AgendaStatus.
     * @param {AgendaStatusUpdateArgs} args - Arguments to update one AgendaStatus.
     * @example
     * // Update one AgendaStatus
     * const agendaStatus = await prisma.agendaStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgendaStatusUpdateArgs>(
      args: SelectSubset<T, AgendaStatusUpdateArgs>
    ): Prisma__AgendaStatusClient<AgendaStatusGetPayload<T>>

    /**
     * Delete zero or more AgendaStatuses.
     * @param {AgendaStatusDeleteManyArgs} args - Arguments to filter AgendaStatuses to delete.
     * @example
     * // Delete a few AgendaStatuses
     * const { count } = await prisma.agendaStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgendaStatusDeleteManyArgs>(
      args?: SelectSubset<T, AgendaStatusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgendaStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgendaStatuses
     * const agendaStatus = await prisma.agendaStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgendaStatusUpdateManyArgs>(
      args: SelectSubset<T, AgendaStatusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AgendaStatus.
     * @param {AgendaStatusUpsertArgs} args - Arguments to update or create a AgendaStatus.
     * @example
     * // Update or create a AgendaStatus
     * const agendaStatus = await prisma.agendaStatus.upsert({
     *   create: {
     *     // ... data to create a AgendaStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgendaStatus we want to update
     *   }
     * })
    **/
    upsert<T extends AgendaStatusUpsertArgs>(
      args: SelectSubset<T, AgendaStatusUpsertArgs>
    ): Prisma__AgendaStatusClient<AgendaStatusGetPayload<T>>

    /**
     * Count the number of AgendaStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaStatusCountArgs} args - Arguments to filter AgendaStatuses to count.
     * @example
     * // Count the number of AgendaStatuses
     * const count = await prisma.agendaStatus.count({
     *   where: {
     *     // ... the filter for the AgendaStatuses we want to count
     *   }
     * })
    **/
    count<T extends AgendaStatusCountArgs>(
      args?: Subset<T, AgendaStatusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendaStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgendaStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendaStatusAggregateArgs>(args: Subset<T, AgendaStatusAggregateArgs>): PrismaPromise<GetAgendaStatusAggregateType<T>>

    /**
     * Group by AgendaStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendaStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendaStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendaStatusGroupByArgs['orderBy'] }
        : { orderBy?: AgendaStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendaStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendaStatusGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AgendaStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgendaStatusClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    agendado<T extends AgendadoArgs= {}>(args?: Subset<T, AgendadoArgs>): Prisma__AgendadoClient<AgendadoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AgendaStatus base type for findUnique actions
   */
  export type AgendaStatusFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
    /**
     * Filter, which AgendaStatus to fetch.
     * 
    **/
    where: AgendaStatusWhereUniqueInput
  }

  /**
   * AgendaStatus: findUnique
   */
  export interface AgendaStatusFindUniqueArgs extends AgendaStatusFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgendaStatus findUniqueOrThrow
   */
  export type AgendaStatusFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
    /**
     * Filter, which AgendaStatus to fetch.
     * 
    **/
    where: AgendaStatusWhereUniqueInput
  }


  /**
   * AgendaStatus base type for findFirst actions
   */
  export type AgendaStatusFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
    /**
     * Filter, which AgendaStatus to fetch.
     * 
    **/
    where?: AgendaStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendaStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaStatuses.
     * 
    **/
    cursor?: AgendaStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaStatuses.
     * 
    **/
    distinct?: Enumerable<AgendaStatusScalarFieldEnum>
  }

  /**
   * AgendaStatus: findFirst
   */
  export interface AgendaStatusFindFirstArgs extends AgendaStatusFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AgendaStatus findFirstOrThrow
   */
  export type AgendaStatusFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
    /**
     * Filter, which AgendaStatus to fetch.
     * 
    **/
    where?: AgendaStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendaStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgendaStatuses.
     * 
    **/
    cursor?: AgendaStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaStatuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgendaStatuses.
     * 
    **/
    distinct?: Enumerable<AgendaStatusScalarFieldEnum>
  }


  /**
   * AgendaStatus findMany
   */
  export type AgendaStatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
    /**
     * Filter, which AgendaStatuses to fetch.
     * 
    **/
    where?: AgendaStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgendaStatuses to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendaStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgendaStatuses.
     * 
    **/
    cursor?: AgendaStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgendaStatuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgendaStatuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AgendaStatusScalarFieldEnum>
  }


  /**
   * AgendaStatus create
   */
  export type AgendaStatusCreateArgs = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
    /**
     * The data needed to create a AgendaStatus.
     * 
    **/
    data: XOR<AgendaStatusCreateInput, AgendaStatusUncheckedCreateInput>
  }


  /**
   * AgendaStatus createMany
   */
  export type AgendaStatusCreateManyArgs = {
    /**
     * The data used to create many AgendaStatuses.
     * 
    **/
    data: Enumerable<AgendaStatusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AgendaStatus update
   */
  export type AgendaStatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
    /**
     * The data needed to update a AgendaStatus.
     * 
    **/
    data: XOR<AgendaStatusUpdateInput, AgendaStatusUncheckedUpdateInput>
    /**
     * Choose, which AgendaStatus to update.
     * 
    **/
    where: AgendaStatusWhereUniqueInput
  }


  /**
   * AgendaStatus updateMany
   */
  export type AgendaStatusUpdateManyArgs = {
    /**
     * The data used to update AgendaStatuses.
     * 
    **/
    data: XOR<AgendaStatusUpdateManyMutationInput, AgendaStatusUncheckedUpdateManyInput>
    /**
     * Filter which AgendaStatuses to update
     * 
    **/
    where?: AgendaStatusWhereInput
  }


  /**
   * AgendaStatus upsert
   */
  export type AgendaStatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
    /**
     * The filter to search for the AgendaStatus to update in case it exists.
     * 
    **/
    where: AgendaStatusWhereUniqueInput
    /**
     * In case the AgendaStatus found by the `where` argument doesn't exist, create a new AgendaStatus with this data.
     * 
    **/
    create: XOR<AgendaStatusCreateInput, AgendaStatusUncheckedCreateInput>
    /**
     * In case the AgendaStatus was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AgendaStatusUpdateInput, AgendaStatusUncheckedUpdateInput>
  }


  /**
   * AgendaStatus delete
   */
  export type AgendaStatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
    /**
     * Filter which AgendaStatus to delete.
     * 
    **/
    where: AgendaStatusWhereUniqueInput
  }


  /**
   * AgendaStatus deleteMany
   */
  export type AgendaStatusDeleteManyArgs = {
    /**
     * Filter which AgendaStatuses to delete
     * 
    **/
    where?: AgendaStatusWhereInput
  }


  /**
   * AgendaStatus without action
   */
  export type AgendaStatusArgs = {
    /**
     * Select specific fields to fetch from the AgendaStatus
     * 
    **/
    select?: AgendaStatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendaStatusInclude | null
  }



  /**
   * Model Agendado
   */


  export type AggregateAgendado = {
    _count: AgendadoCountAggregateOutputType | null
    _avg: AgendadoAvgAggregateOutputType | null
    _sum: AgendadoSumAggregateOutputType | null
    _min: AgendadoMinAggregateOutputType | null
    _max: AgendadoMaxAggregateOutputType | null
  }

  export type AgendadoAvgAggregateOutputType = {
    agendadoId: number | null
  }

  export type AgendadoSumAggregateOutputType = {
    agendadoId: number | null
  }

  export type AgendadoMinAggregateOutputType = {
    id: string | null
    agendadoId: number | null
  }

  export type AgendadoMaxAggregateOutputType = {
    id: string | null
    agendadoId: number | null
  }

  export type AgendadoCountAggregateOutputType = {
    id: number
    agendadoId: number
    _all: number
  }


  export type AgendadoAvgAggregateInputType = {
    agendadoId?: true
  }

  export type AgendadoSumAggregateInputType = {
    agendadoId?: true
  }

  export type AgendadoMinAggregateInputType = {
    id?: true
    agendadoId?: true
  }

  export type AgendadoMaxAggregateInputType = {
    id?: true
    agendadoId?: true
  }

  export type AgendadoCountAggregateInputType = {
    id?: true
    agendadoId?: true
    _all?: true
  }

  export type AgendadoAggregateArgs = {
    /**
     * Filter which Agendado to aggregate.
     * 
    **/
    where?: AgendadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agendados to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AgendadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agendados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agendados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agendados
    **/
    _count?: true | AgendadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgendadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgendadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgendadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgendadoMaxAggregateInputType
  }

  export type GetAgendadoAggregateType<T extends AgendadoAggregateArgs> = {
        [P in keyof T & keyof AggregateAgendado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgendado[P]>
      : GetScalarType<T[P], AggregateAgendado[P]>
  }




  export type AgendadoGroupByArgs = {
    where?: AgendadoWhereInput
    orderBy?: Enumerable<AgendadoOrderByWithAggregationInput>
    by: Array<AgendadoScalarFieldEnum>
    having?: AgendadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgendadoCountAggregateInputType | true
    _avg?: AgendadoAvgAggregateInputType
    _sum?: AgendadoSumAggregateInputType
    _min?: AgendadoMinAggregateInputType
    _max?: AgendadoMaxAggregateInputType
  }


  export type AgendadoGroupByOutputType = {
    id: string
    agendadoId: number
    _count: AgendadoCountAggregateOutputType | null
    _avg: AgendadoAvgAggregateOutputType | null
    _sum: AgendadoSumAggregateOutputType | null
    _min: AgendadoMinAggregateOutputType | null
    _max: AgendadoMaxAggregateOutputType | null
  }

  type GetAgendadoGroupByPayload<T extends AgendadoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AgendadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgendadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgendadoGroupByOutputType[P]>
            : GetScalarType<T[P], AgendadoGroupByOutputType[P]>
        }
      >
    >


  export type AgendadoSelect = {
    id?: boolean
    agendadoId?: boolean
    status?: boolean | AgendaStatusFindManyArgs
    agenda?: boolean | AgendaFindManyArgs
    _count?: boolean | AgendadoCountOutputTypeArgs
  }


  export type AgendadoInclude = {
    status?: boolean | AgendaStatusFindManyArgs
    agenda?: boolean | AgendaFindManyArgs
    _count?: boolean | AgendadoCountOutputTypeArgs
  } 

  export type AgendadoGetPayload<S extends boolean | null | undefined | AgendadoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Agendado :
    S extends undefined ? never :
    S extends { include: any } & (AgendadoArgs | AgendadoFindManyArgs)
    ? Agendado  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'status' ? Array < AgendaStatusGetPayload<S['include'][P]>>  :
        P extends 'agenda' ? Array < AgendaGetPayload<S['include'][P]>>  :
        P extends '_count' ? AgendadoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AgendadoArgs | AgendadoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'status' ? Array < AgendaStatusGetPayload<S['select'][P]>>  :
        P extends 'agenda' ? Array < AgendaGetPayload<S['select'][P]>>  :
        P extends '_count' ? AgendadoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Agendado ? Agendado[P] : never
  } 
      : Agendado


  type AgendadoCountArgs = Merge<
    Omit<AgendadoFindManyArgs, 'select' | 'include'> & {
      select?: AgendadoCountAggregateInputType | true
    }
  >

  export interface AgendadoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Agendado that matches the filter.
     * @param {AgendadoFindUniqueArgs} args - Arguments to find a Agendado
     * @example
     * // Get one Agendado
     * const agendado = await prisma.agendado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgendadoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgendadoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Agendado'> extends True ? Prisma__AgendadoClient<AgendadoGetPayload<T>> : Prisma__AgendadoClient<AgendadoGetPayload<T> | null, null>

    /**
     * Find one Agendado that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgendadoFindUniqueOrThrowArgs} args - Arguments to find a Agendado
     * @example
     * // Get one Agendado
     * const agendado = await prisma.agendado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgendadoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AgendadoFindUniqueOrThrowArgs>
    ): Prisma__AgendadoClient<AgendadoGetPayload<T>>

    /**
     * Find the first Agendado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendadoFindFirstArgs} args - Arguments to find a Agendado
     * @example
     * // Get one Agendado
     * const agendado = await prisma.agendado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgendadoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgendadoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Agendado'> extends True ? Prisma__AgendadoClient<AgendadoGetPayload<T>> : Prisma__AgendadoClient<AgendadoGetPayload<T> | null, null>

    /**
     * Find the first Agendado that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendadoFindFirstOrThrowArgs} args - Arguments to find a Agendado
     * @example
     * // Get one Agendado
     * const agendado = await prisma.agendado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgendadoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AgendadoFindFirstOrThrowArgs>
    ): Prisma__AgendadoClient<AgendadoGetPayload<T>>

    /**
     * Find zero or more Agendados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agendados
     * const agendados = await prisma.agendado.findMany()
     * 
     * // Get first 10 Agendados
     * const agendados = await prisma.agendado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agendadoWithIdOnly = await prisma.agendado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AgendadoFindManyArgs>(
      args?: SelectSubset<T, AgendadoFindManyArgs>
    ): PrismaPromise<Array<AgendadoGetPayload<T>>>

    /**
     * Create a Agendado.
     * @param {AgendadoCreateArgs} args - Arguments to create a Agendado.
     * @example
     * // Create one Agendado
     * const Agendado = await prisma.agendado.create({
     *   data: {
     *     // ... data to create a Agendado
     *   }
     * })
     * 
    **/
    create<T extends AgendadoCreateArgs>(
      args: SelectSubset<T, AgendadoCreateArgs>
    ): Prisma__AgendadoClient<AgendadoGetPayload<T>>

    /**
     * Create many Agendados.
     *     @param {AgendadoCreateManyArgs} args - Arguments to create many Agendados.
     *     @example
     *     // Create many Agendados
     *     const agendado = await prisma.agendado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgendadoCreateManyArgs>(
      args?: SelectSubset<T, AgendadoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Agendado.
     * @param {AgendadoDeleteArgs} args - Arguments to delete one Agendado.
     * @example
     * // Delete one Agendado
     * const Agendado = await prisma.agendado.delete({
     *   where: {
     *     // ... filter to delete one Agendado
     *   }
     * })
     * 
    **/
    delete<T extends AgendadoDeleteArgs>(
      args: SelectSubset<T, AgendadoDeleteArgs>
    ): Prisma__AgendadoClient<AgendadoGetPayload<T>>

    /**
     * Update one Agendado.
     * @param {AgendadoUpdateArgs} args - Arguments to update one Agendado.
     * @example
     * // Update one Agendado
     * const agendado = await prisma.agendado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgendadoUpdateArgs>(
      args: SelectSubset<T, AgendadoUpdateArgs>
    ): Prisma__AgendadoClient<AgendadoGetPayload<T>>

    /**
     * Delete zero or more Agendados.
     * @param {AgendadoDeleteManyArgs} args - Arguments to filter Agendados to delete.
     * @example
     * // Delete a few Agendados
     * const { count } = await prisma.agendado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgendadoDeleteManyArgs>(
      args?: SelectSubset<T, AgendadoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agendados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agendados
     * const agendado = await prisma.agendado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgendadoUpdateManyArgs>(
      args: SelectSubset<T, AgendadoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Agendado.
     * @param {AgendadoUpsertArgs} args - Arguments to update or create a Agendado.
     * @example
     * // Update or create a Agendado
     * const agendado = await prisma.agendado.upsert({
     *   create: {
     *     // ... data to create a Agendado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agendado we want to update
     *   }
     * })
    **/
    upsert<T extends AgendadoUpsertArgs>(
      args: SelectSubset<T, AgendadoUpsertArgs>
    ): Prisma__AgendadoClient<AgendadoGetPayload<T>>

    /**
     * Count the number of Agendados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendadoCountArgs} args - Arguments to filter Agendados to count.
     * @example
     * // Count the number of Agendados
     * const count = await prisma.agendado.count({
     *   where: {
     *     // ... the filter for the Agendados we want to count
     *   }
     * })
    **/
    count<T extends AgendadoCountArgs>(
      args?: Subset<T, AgendadoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgendadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agendado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgendadoAggregateArgs>(args: Subset<T, AgendadoAggregateArgs>): PrismaPromise<GetAgendadoAggregateType<T>>

    /**
     * Group by Agendado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgendadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgendadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgendadoGroupByArgs['orderBy'] }
        : { orderBy?: AgendadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgendadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgendadoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Agendado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgendadoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    status<T extends AgendaStatusFindManyArgs= {}>(args?: Subset<T, AgendaStatusFindManyArgs>): PrismaPromise<Array<AgendaStatusGetPayload<T>>| Null>;

    agenda<T extends AgendaFindManyArgs= {}>(args?: Subset<T, AgendaFindManyArgs>): PrismaPromise<Array<AgendaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Agendado base type for findUnique actions
   */
  export type AgendadoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
    /**
     * Filter, which Agendado to fetch.
     * 
    **/
    where: AgendadoWhereUniqueInput
  }

  /**
   * Agendado: findUnique
   */
  export interface AgendadoFindUniqueArgs extends AgendadoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Agendado findUniqueOrThrow
   */
  export type AgendadoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
    /**
     * Filter, which Agendado to fetch.
     * 
    **/
    where: AgendadoWhereUniqueInput
  }


  /**
   * Agendado base type for findFirst actions
   */
  export type AgendadoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
    /**
     * Filter, which Agendado to fetch.
     * 
    **/
    where?: AgendadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agendados to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agendados.
     * 
    **/
    cursor?: AgendadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agendados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agendados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agendados.
     * 
    **/
    distinct?: Enumerable<AgendadoScalarFieldEnum>
  }

  /**
   * Agendado: findFirst
   */
  export interface AgendadoFindFirstArgs extends AgendadoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Agendado findFirstOrThrow
   */
  export type AgendadoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
    /**
     * Filter, which Agendado to fetch.
     * 
    **/
    where?: AgendadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agendados to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agendados.
     * 
    **/
    cursor?: AgendadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agendados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agendados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agendados.
     * 
    **/
    distinct?: Enumerable<AgendadoScalarFieldEnum>
  }


  /**
   * Agendado findMany
   */
  export type AgendadoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
    /**
     * Filter, which Agendados to fetch.
     * 
    **/
    where?: AgendadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agendados to fetch.
     * 
    **/
    orderBy?: Enumerable<AgendadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agendados.
     * 
    **/
    cursor?: AgendadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agendados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agendados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AgendadoScalarFieldEnum>
  }


  /**
   * Agendado create
   */
  export type AgendadoCreateArgs = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
    /**
     * The data needed to create a Agendado.
     * 
    **/
    data: XOR<AgendadoCreateInput, AgendadoUncheckedCreateInput>
  }


  /**
   * Agendado createMany
   */
  export type AgendadoCreateManyArgs = {
    /**
     * The data used to create many Agendados.
     * 
    **/
    data: Enumerable<AgendadoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Agendado update
   */
  export type AgendadoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
    /**
     * The data needed to update a Agendado.
     * 
    **/
    data: XOR<AgendadoUpdateInput, AgendadoUncheckedUpdateInput>
    /**
     * Choose, which Agendado to update.
     * 
    **/
    where: AgendadoWhereUniqueInput
  }


  /**
   * Agendado updateMany
   */
  export type AgendadoUpdateManyArgs = {
    /**
     * The data used to update Agendados.
     * 
    **/
    data: XOR<AgendadoUpdateManyMutationInput, AgendadoUncheckedUpdateManyInput>
    /**
     * Filter which Agendados to update
     * 
    **/
    where?: AgendadoWhereInput
  }


  /**
   * Agendado upsert
   */
  export type AgendadoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
    /**
     * The filter to search for the Agendado to update in case it exists.
     * 
    **/
    where: AgendadoWhereUniqueInput
    /**
     * In case the Agendado found by the `where` argument doesn't exist, create a new Agendado with this data.
     * 
    **/
    create: XOR<AgendadoCreateInput, AgendadoUncheckedCreateInput>
    /**
     * In case the Agendado was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AgendadoUpdateInput, AgendadoUncheckedUpdateInput>
  }


  /**
   * Agendado delete
   */
  export type AgendadoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
    /**
     * Filter which Agendado to delete.
     * 
    **/
    where: AgendadoWhereUniqueInput
  }


  /**
   * Agendado deleteMany
   */
  export type AgendadoDeleteManyArgs = {
    /**
     * Filter which Agendados to delete
     * 
    **/
    where?: AgendadoWhereInput
  }


  /**
   * Agendado without action
   */
  export type AgendadoArgs = {
    /**
     * Select specific fields to fetch from the Agendado
     * 
    **/
    select?: AgendadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AgendadoInclude | null
  }



  /**
   * Model Produtos
   */


  export type AggregateProdutos = {
    _count: ProdutosCountAggregateOutputType | null
    _avg: ProdutosAvgAggregateOutputType | null
    _sum: ProdutosSumAggregateOutputType | null
    _min: ProdutosMinAggregateOutputType | null
    _max: ProdutosMaxAggregateOutputType | null
  }

  export type ProdutosAvgAggregateOutputType = {
    preco: number | null
  }

  export type ProdutosSumAggregateOutputType = {
    preco: number | null
  }

  export type ProdutosMinAggregateOutputType = {
    id: string | null
    nomeProduto: string | null
    preco: number | null
    descricao: string | null
  }

  export type ProdutosMaxAggregateOutputType = {
    id: string | null
    nomeProduto: string | null
    preco: number | null
    descricao: string | null
  }

  export type ProdutosCountAggregateOutputType = {
    id: number
    nomeProduto: number
    preco: number
    descricao: number
    _all: number
  }


  export type ProdutosAvgAggregateInputType = {
    preco?: true
  }

  export type ProdutosSumAggregateInputType = {
    preco?: true
  }

  export type ProdutosMinAggregateInputType = {
    id?: true
    nomeProduto?: true
    preco?: true
    descricao?: true
  }

  export type ProdutosMaxAggregateInputType = {
    id?: true
    nomeProduto?: true
    preco?: true
    descricao?: true
  }

  export type ProdutosCountAggregateInputType = {
    id?: true
    nomeProduto?: true
    preco?: true
    descricao?: true
    _all?: true
  }

  export type ProdutosAggregateArgs = {
    /**
     * Filter which Produtos to aggregate.
     * 
    **/
    where?: ProdutosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProdutosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProdutosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Produtos
    **/
    _count?: true | ProdutosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProdutosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProdutosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProdutosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProdutosMaxAggregateInputType
  }

  export type GetProdutosAggregateType<T extends ProdutosAggregateArgs> = {
        [P in keyof T & keyof AggregateProdutos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProdutos[P]>
      : GetScalarType<T[P], AggregateProdutos[P]>
  }




  export type ProdutosGroupByArgs = {
    where?: ProdutosWhereInput
    orderBy?: Enumerable<ProdutosOrderByWithAggregationInput>
    by: Array<ProdutosScalarFieldEnum>
    having?: ProdutosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProdutosCountAggregateInputType | true
    _avg?: ProdutosAvgAggregateInputType
    _sum?: ProdutosSumAggregateInputType
    _min?: ProdutosMinAggregateInputType
    _max?: ProdutosMaxAggregateInputType
  }


  export type ProdutosGroupByOutputType = {
    id: string
    nomeProduto: string
    preco: number
    descricao: string
    _count: ProdutosCountAggregateOutputType | null
    _avg: ProdutosAvgAggregateOutputType | null
    _sum: ProdutosSumAggregateOutputType | null
    _min: ProdutosMinAggregateOutputType | null
    _max: ProdutosMaxAggregateOutputType | null
  }

  type GetProdutosGroupByPayload<T extends ProdutosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProdutosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProdutosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProdutosGroupByOutputType[P]>
            : GetScalarType<T[P], ProdutosGroupByOutputType[P]>
        }
      >
    >


  export type ProdutosSelect = {
    id?: boolean
    nomeProduto?: boolean
    preco?: boolean
    descricao?: boolean
  }


  export type ProdutosGetPayload<S extends boolean | null | undefined | ProdutosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Produtos :
    S extends undefined ? never :
    S extends { include: any } & (ProdutosArgs | ProdutosFindManyArgs)
    ? Produtos 
    : S extends { select: any } & (ProdutosArgs | ProdutosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Produtos ? Produtos[P] : never
  } 
      : Produtos


  type ProdutosCountArgs = Merge<
    Omit<ProdutosFindManyArgs, 'select' | 'include'> & {
      select?: ProdutosCountAggregateInputType | true
    }
  >

  export interface ProdutosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Produtos that matches the filter.
     * @param {ProdutosFindUniqueArgs} args - Arguments to find a Produtos
     * @example
     * // Get one Produtos
     * const produtos = await prisma.produtos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProdutosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProdutosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Produtos'> extends True ? Prisma__ProdutosClient<ProdutosGetPayload<T>> : Prisma__ProdutosClient<ProdutosGetPayload<T> | null, null>

    /**
     * Find one Produtos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProdutosFindUniqueOrThrowArgs} args - Arguments to find a Produtos
     * @example
     * // Get one Produtos
     * const produtos = await prisma.produtos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProdutosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProdutosFindUniqueOrThrowArgs>
    ): Prisma__ProdutosClient<ProdutosGetPayload<T>>

    /**
     * Find the first Produtos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosFindFirstArgs} args - Arguments to find a Produtos
     * @example
     * // Get one Produtos
     * const produtos = await prisma.produtos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProdutosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProdutosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Produtos'> extends True ? Prisma__ProdutosClient<ProdutosGetPayload<T>> : Prisma__ProdutosClient<ProdutosGetPayload<T> | null, null>

    /**
     * Find the first Produtos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosFindFirstOrThrowArgs} args - Arguments to find a Produtos
     * @example
     * // Get one Produtos
     * const produtos = await prisma.produtos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProdutosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProdutosFindFirstOrThrowArgs>
    ): Prisma__ProdutosClient<ProdutosGetPayload<T>>

    /**
     * Find zero or more Produtos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produtos
     * const produtos = await prisma.produtos.findMany()
     * 
     * // Get first 10 Produtos
     * const produtos = await prisma.produtos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produtosWithIdOnly = await prisma.produtos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProdutosFindManyArgs>(
      args?: SelectSubset<T, ProdutosFindManyArgs>
    ): PrismaPromise<Array<ProdutosGetPayload<T>>>

    /**
     * Create a Produtos.
     * @param {ProdutosCreateArgs} args - Arguments to create a Produtos.
     * @example
     * // Create one Produtos
     * const Produtos = await prisma.produtos.create({
     *   data: {
     *     // ... data to create a Produtos
     *   }
     * })
     * 
    **/
    create<T extends ProdutosCreateArgs>(
      args: SelectSubset<T, ProdutosCreateArgs>
    ): Prisma__ProdutosClient<ProdutosGetPayload<T>>

    /**
     * Create many Produtos.
     *     @param {ProdutosCreateManyArgs} args - Arguments to create many Produtos.
     *     @example
     *     // Create many Produtos
     *     const produtos = await prisma.produtos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProdutosCreateManyArgs>(
      args?: SelectSubset<T, ProdutosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Produtos.
     * @param {ProdutosDeleteArgs} args - Arguments to delete one Produtos.
     * @example
     * // Delete one Produtos
     * const Produtos = await prisma.produtos.delete({
     *   where: {
     *     // ... filter to delete one Produtos
     *   }
     * })
     * 
    **/
    delete<T extends ProdutosDeleteArgs>(
      args: SelectSubset<T, ProdutosDeleteArgs>
    ): Prisma__ProdutosClient<ProdutosGetPayload<T>>

    /**
     * Update one Produtos.
     * @param {ProdutosUpdateArgs} args - Arguments to update one Produtos.
     * @example
     * // Update one Produtos
     * const produtos = await prisma.produtos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProdutosUpdateArgs>(
      args: SelectSubset<T, ProdutosUpdateArgs>
    ): Prisma__ProdutosClient<ProdutosGetPayload<T>>

    /**
     * Delete zero or more Produtos.
     * @param {ProdutosDeleteManyArgs} args - Arguments to filter Produtos to delete.
     * @example
     * // Delete a few Produtos
     * const { count } = await prisma.produtos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProdutosDeleteManyArgs>(
      args?: SelectSubset<T, ProdutosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produtos
     * const produtos = await prisma.produtos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProdutosUpdateManyArgs>(
      args: SelectSubset<T, ProdutosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Produtos.
     * @param {ProdutosUpsertArgs} args - Arguments to update or create a Produtos.
     * @example
     * // Update or create a Produtos
     * const produtos = await prisma.produtos.upsert({
     *   create: {
     *     // ... data to create a Produtos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produtos we want to update
     *   }
     * })
    **/
    upsert<T extends ProdutosUpsertArgs>(
      args: SelectSubset<T, ProdutosUpsertArgs>
    ): Prisma__ProdutosClient<ProdutosGetPayload<T>>

    /**
     * Count the number of Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosCountArgs} args - Arguments to filter Produtos to count.
     * @example
     * // Count the number of Produtos
     * const count = await prisma.produtos.count({
     *   where: {
     *     // ... the filter for the Produtos we want to count
     *   }
     * })
    **/
    count<T extends ProdutosCountArgs>(
      args?: Subset<T, ProdutosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProdutosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProdutosAggregateArgs>(args: Subset<T, ProdutosAggregateArgs>): PrismaPromise<GetProdutosAggregateType<T>>

    /**
     * Group by Produtos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProdutosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProdutosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProdutosGroupByArgs['orderBy'] }
        : { orderBy?: ProdutosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProdutosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProdutosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Produtos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProdutosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Produtos base type for findUnique actions
   */
  export type ProdutosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
    /**
     * Filter, which Produtos to fetch.
     * 
    **/
    where: ProdutosWhereUniqueInput
  }

  /**
   * Produtos: findUnique
   */
  export interface ProdutosFindUniqueArgs extends ProdutosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Produtos findUniqueOrThrow
   */
  export type ProdutosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
    /**
     * Filter, which Produtos to fetch.
     * 
    **/
    where: ProdutosWhereUniqueInput
  }


  /**
   * Produtos base type for findFirst actions
   */
  export type ProdutosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
    /**
     * Filter, which Produtos to fetch.
     * 
    **/
    where?: ProdutosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProdutosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     * 
    **/
    cursor?: ProdutosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     * 
    **/
    distinct?: Enumerable<ProdutosScalarFieldEnum>
  }

  /**
   * Produtos: findFirst
   */
  export interface ProdutosFindFirstArgs extends ProdutosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Produtos findFirstOrThrow
   */
  export type ProdutosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
    /**
     * Filter, which Produtos to fetch.
     * 
    **/
    where?: ProdutosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProdutosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produtos.
     * 
    **/
    cursor?: ProdutosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produtos.
     * 
    **/
    distinct?: Enumerable<ProdutosScalarFieldEnum>
  }


  /**
   * Produtos findMany
   */
  export type ProdutosFindManyArgs = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
    /**
     * Filter, which Produtos to fetch.
     * 
    **/
    where?: ProdutosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produtos to fetch.
     * 
    **/
    orderBy?: Enumerable<ProdutosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Produtos.
     * 
    **/
    cursor?: ProdutosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produtos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produtos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProdutosScalarFieldEnum>
  }


  /**
   * Produtos create
   */
  export type ProdutosCreateArgs = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
    /**
     * The data needed to create a Produtos.
     * 
    **/
    data: XOR<ProdutosCreateInput, ProdutosUncheckedCreateInput>
  }


  /**
   * Produtos createMany
   */
  export type ProdutosCreateManyArgs = {
    /**
     * The data used to create many Produtos.
     * 
    **/
    data: Enumerable<ProdutosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Produtos update
   */
  export type ProdutosUpdateArgs = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
    /**
     * The data needed to update a Produtos.
     * 
    **/
    data: XOR<ProdutosUpdateInput, ProdutosUncheckedUpdateInput>
    /**
     * Choose, which Produtos to update.
     * 
    **/
    where: ProdutosWhereUniqueInput
  }


  /**
   * Produtos updateMany
   */
  export type ProdutosUpdateManyArgs = {
    /**
     * The data used to update Produtos.
     * 
    **/
    data: XOR<ProdutosUpdateManyMutationInput, ProdutosUncheckedUpdateManyInput>
    /**
     * Filter which Produtos to update
     * 
    **/
    where?: ProdutosWhereInput
  }


  /**
   * Produtos upsert
   */
  export type ProdutosUpsertArgs = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
    /**
     * The filter to search for the Produtos to update in case it exists.
     * 
    **/
    where: ProdutosWhereUniqueInput
    /**
     * In case the Produtos found by the `where` argument doesn't exist, create a new Produtos with this data.
     * 
    **/
    create: XOR<ProdutosCreateInput, ProdutosUncheckedCreateInput>
    /**
     * In case the Produtos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProdutosUpdateInput, ProdutosUncheckedUpdateInput>
  }


  /**
   * Produtos delete
   */
  export type ProdutosDeleteArgs = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
    /**
     * Filter which Produtos to delete.
     * 
    **/
    where: ProdutosWhereUniqueInput
  }


  /**
   * Produtos deleteMany
   */
  export type ProdutosDeleteManyArgs = {
    /**
     * Filter which Produtos to delete
     * 
    **/
    where?: ProdutosWhereInput
  }


  /**
   * Produtos without action
   */
  export type ProdutosArgs = {
    /**
     * Select specific fields to fetch from the Produtos
     * 
    **/
    select?: ProdutosSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AgendaScalarFieldEnum: {
    id: 'id',
    horario: 'horario',
    dia: 'dia',
    agendaId: 'agendaId'
  };

  export type AgendaScalarFieldEnum = (typeof AgendaScalarFieldEnum)[keyof typeof AgendaScalarFieldEnum]


  export const AgendaStatusScalarFieldEnum: {
    id: 'id',
    nomeStatus: 'nomeStatus',
    descricao: 'descricao',
    statusId: 'statusId'
  };

  export type AgendaStatusScalarFieldEnum = (typeof AgendaStatusScalarFieldEnum)[keyof typeof AgendaStatusScalarFieldEnum]


  export const AgendadoScalarFieldEnum: {
    id: 'id',
    agendadoId: 'agendadoId'
  };

  export type AgendadoScalarFieldEnum = (typeof AgendadoScalarFieldEnum)[keyof typeof AgendadoScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id: 'id',
    nomeCategoria: 'nomeCategoria',
    descricao: 'descricao',
    servicoId: 'servicoId'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    CPF: 'CPF',
    Nome: 'Nome',
    email: 'email',
    senha: 'senha'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const PrestadorScalarFieldEnum: {
    CNPJ: 'CNPJ',
    Nome: 'Nome',
    email: 'email',
    Senha: 'Senha'
  };

  export type PrestadorScalarFieldEnum = (typeof PrestadorScalarFieldEnum)[keyof typeof PrestadorScalarFieldEnum]


  export const ProdutosScalarFieldEnum: {
    id: 'id',
    nomeProduto: 'nomeProduto',
    preco: 'preco',
    descricao: 'descricao'
  };

  export type ProdutosScalarFieldEnum = (typeof ProdutosScalarFieldEnum)[keyof typeof ProdutosScalarFieldEnum]


  export const ServicoScalarFieldEnum: {
    id: 'id',
    NomeServico: 'NomeServico',
    preco: 'preco',
    descricao: 'descricao',
    img: 'img',
    servicoId: 'servicoId'
  };

  export type ServicoScalarFieldEnum = (typeof ServicoScalarFieldEnum)[keyof typeof ServicoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type ClienteWhereInput = {
    AND?: Enumerable<ClienteWhereInput>
    OR?: Enumerable<ClienteWhereInput>
    NOT?: Enumerable<ClienteWhereInput>
    CPF?: StringFilter | string
    Nome?: StringFilter | string
    email?: StringFilter | string
    senha?: StringFilter | string
  }

  export type ClienteOrderByWithRelationInput = {
    CPF?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
  }

  export type ClienteWhereUniqueInput = {
    CPF?: string
    email?: string
  }

  export type ClienteOrderByWithAggregationInput = {
    CPF?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ClienteScalarWhereWithAggregatesInput>
    OR?: Enumerable<ClienteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ClienteScalarWhereWithAggregatesInput>
    CPF?: StringWithAggregatesFilter | string
    Nome?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    senha?: StringWithAggregatesFilter | string
  }

  export type PrestadorWhereInput = {
    AND?: Enumerable<PrestadorWhereInput>
    OR?: Enumerable<PrestadorWhereInput>
    NOT?: Enumerable<PrestadorWhereInput>
    CNPJ?: StringFilter | string
    Nome?: StringFilter | string
    email?: StringFilter | string
    Senha?: StringFilter | string
    servicos?: ServicoListRelationFilter
  }

  export type PrestadorOrderByWithRelationInput = {
    CNPJ?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    Senha?: SortOrder
    servicos?: ServicoOrderByRelationAggregateInput
  }

  export type PrestadorWhereUniqueInput = {
    CNPJ?: string
    email?: string
  }

  export type PrestadorOrderByWithAggregationInput = {
    CNPJ?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    Senha?: SortOrder
    _count?: PrestadorCountOrderByAggregateInput
    _max?: PrestadorMaxOrderByAggregateInput
    _min?: PrestadorMinOrderByAggregateInput
  }

  export type PrestadorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PrestadorScalarWhereWithAggregatesInput>
    OR?: Enumerable<PrestadorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PrestadorScalarWhereWithAggregatesInput>
    CNPJ?: StringWithAggregatesFilter | string
    Nome?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    Senha?: StringWithAggregatesFilter | string
  }

  export type ServicoWhereInput = {
    AND?: Enumerable<ServicoWhereInput>
    OR?: Enumerable<ServicoWhereInput>
    NOT?: Enumerable<ServicoWhereInput>
    id?: StringFilter | string
    NomeServico?: StringFilter | string
    preco?: FloatFilter | number
    descricao?: StringFilter | string
    img?: StringFilter | string
    servicoId?: StringFilter | string
    prestador?: XOR<PrestadorRelationFilter, PrestadorWhereInput>
    categoria?: CategoriaListRelationFilter
  }

  export type ServicoOrderByWithRelationInput = {
    id?: SortOrder
    NomeServico?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
    img?: SortOrder
    servicoId?: SortOrder
    prestador?: PrestadorOrderByWithRelationInput
    categoria?: CategoriaOrderByRelationAggregateInput
  }

  export type ServicoWhereUniqueInput = {
    id?: string
  }

  export type ServicoOrderByWithAggregationInput = {
    id?: SortOrder
    NomeServico?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
    img?: SortOrder
    servicoId?: SortOrder
    _count?: ServicoCountOrderByAggregateInput
    _avg?: ServicoAvgOrderByAggregateInput
    _max?: ServicoMaxOrderByAggregateInput
    _min?: ServicoMinOrderByAggregateInput
    _sum?: ServicoSumOrderByAggregateInput
  }

  export type ServicoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServicoScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServicoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServicoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    NomeServico?: StringWithAggregatesFilter | string
    preco?: FloatWithAggregatesFilter | number
    descricao?: StringWithAggregatesFilter | string
    img?: StringWithAggregatesFilter | string
    servicoId?: StringWithAggregatesFilter | string
  }

  export type CategoriaWhereInput = {
    AND?: Enumerable<CategoriaWhereInput>
    OR?: Enumerable<CategoriaWhereInput>
    NOT?: Enumerable<CategoriaWhereInput>
    id?: StringFilter | string
    nomeCategoria?: StringFilter | string
    descricao?: StringFilter | string
    servicoId?: StringNullableFilter | string | null
    servico?: XOR<ServicoRelationFilter, ServicoWhereInput> | null
  }

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nomeCategoria?: SortOrder
    descricao?: SortOrder
    servicoId?: SortOrder
    servico?: ServicoOrderByWithRelationInput
  }

  export type CategoriaWhereUniqueInput = {
    id?: string
    nomeCategoria?: string
  }

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nomeCategoria?: SortOrder
    descricao?: SortOrder
    servicoId?: SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoriaScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoriaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoriaScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nomeCategoria?: StringWithAggregatesFilter | string
    descricao?: StringWithAggregatesFilter | string
    servicoId?: StringNullableWithAggregatesFilter | string | null
  }

  export type AgendaWhereInput = {
    AND?: Enumerable<AgendaWhereInput>
    OR?: Enumerable<AgendaWhereInput>
    NOT?: Enumerable<AgendaWhereInput>
    id?: StringFilter | string
    horario?: DateTimeFilter | Date | string
    dia?: DateTimeFilter | Date | string
    agendaId?: StringFilter | string
    agendado?: XOR<AgendadoRelationFilter, AgendadoWhereInput>
  }

  export type AgendaOrderByWithRelationInput = {
    id?: SortOrder
    horario?: SortOrder
    dia?: SortOrder
    agendaId?: SortOrder
    agendado?: AgendadoOrderByWithRelationInput
  }

  export type AgendaWhereUniqueInput = {
    id?: string
  }

  export type AgendaOrderByWithAggregationInput = {
    id?: SortOrder
    horario?: SortOrder
    dia?: SortOrder
    agendaId?: SortOrder
    _count?: AgendaCountOrderByAggregateInput
    _max?: AgendaMaxOrderByAggregateInput
    _min?: AgendaMinOrderByAggregateInput
  }

  export type AgendaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgendaScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgendaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgendaScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    horario?: DateTimeWithAggregatesFilter | Date | string
    dia?: DateTimeWithAggregatesFilter | Date | string
    agendaId?: StringWithAggregatesFilter | string
  }

  export type AgendaStatusWhereInput = {
    AND?: Enumerable<AgendaStatusWhereInput>
    OR?: Enumerable<AgendaStatusWhereInput>
    NOT?: Enumerable<AgendaStatusWhereInput>
    id?: StringFilter | string
    nomeStatus?: StringFilter | string
    descricao?: StringFilter | string
    statusId?: StringFilter | string
    agendado?: XOR<AgendadoRelationFilter, AgendadoWhereInput>
  }

  export type AgendaStatusOrderByWithRelationInput = {
    id?: SortOrder
    nomeStatus?: SortOrder
    descricao?: SortOrder
    statusId?: SortOrder
    agendado?: AgendadoOrderByWithRelationInput
  }

  export type AgendaStatusWhereUniqueInput = {
    id?: string
    nomeStatus?: string
  }

  export type AgendaStatusOrderByWithAggregationInput = {
    id?: SortOrder
    nomeStatus?: SortOrder
    descricao?: SortOrder
    statusId?: SortOrder
    _count?: AgendaStatusCountOrderByAggregateInput
    _max?: AgendaStatusMaxOrderByAggregateInput
    _min?: AgendaStatusMinOrderByAggregateInput
  }

  export type AgendaStatusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgendaStatusScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgendaStatusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgendaStatusScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nomeStatus?: StringWithAggregatesFilter | string
    descricao?: StringWithAggregatesFilter | string
    statusId?: StringWithAggregatesFilter | string
  }

  export type AgendadoWhereInput = {
    AND?: Enumerable<AgendadoWhereInput>
    OR?: Enumerable<AgendadoWhereInput>
    NOT?: Enumerable<AgendadoWhereInput>
    id?: StringFilter | string
    agendadoId?: IntFilter | number
    status?: AgendaStatusListRelationFilter
    agenda?: AgendaListRelationFilter
  }

  export type AgendadoOrderByWithRelationInput = {
    id?: SortOrder
    agendadoId?: SortOrder
    status?: AgendaStatusOrderByRelationAggregateInput
    agenda?: AgendaOrderByRelationAggregateInput
  }

  export type AgendadoWhereUniqueInput = {
    id?: string
  }

  export type AgendadoOrderByWithAggregationInput = {
    id?: SortOrder
    agendadoId?: SortOrder
    _count?: AgendadoCountOrderByAggregateInput
    _avg?: AgendadoAvgOrderByAggregateInput
    _max?: AgendadoMaxOrderByAggregateInput
    _min?: AgendadoMinOrderByAggregateInput
    _sum?: AgendadoSumOrderByAggregateInput
  }

  export type AgendadoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgendadoScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgendadoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgendadoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    agendadoId?: IntWithAggregatesFilter | number
  }

  export type ProdutosWhereInput = {
    AND?: Enumerable<ProdutosWhereInput>
    OR?: Enumerable<ProdutosWhereInput>
    NOT?: Enumerable<ProdutosWhereInput>
    id?: StringFilter | string
    nomeProduto?: StringFilter | string
    preco?: FloatFilter | number
    descricao?: StringFilter | string
  }

  export type ProdutosOrderByWithRelationInput = {
    id?: SortOrder
    nomeProduto?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
  }

  export type ProdutosWhereUniqueInput = {
    id?: string
  }

  export type ProdutosOrderByWithAggregationInput = {
    id?: SortOrder
    nomeProduto?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
    _count?: ProdutosCountOrderByAggregateInput
    _avg?: ProdutosAvgOrderByAggregateInput
    _max?: ProdutosMaxOrderByAggregateInput
    _min?: ProdutosMinOrderByAggregateInput
    _sum?: ProdutosSumOrderByAggregateInput
  }

  export type ProdutosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProdutosScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProdutosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProdutosScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nomeProduto?: StringWithAggregatesFilter | string
    preco?: FloatWithAggregatesFilter | number
    descricao?: StringWithAggregatesFilter | string
  }

  export type ClienteCreateInput = {
    CPF?: string
    Nome: string
    email: string
    senha: string
  }

  export type ClienteUncheckedCreateInput = {
    CPF?: string
    Nome: string
    email: string
    senha: string
  }

  export type ClienteUpdateInput = {
    CPF?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type ClienteUncheckedUpdateInput = {
    CPF?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type ClienteCreateManyInput = {
    CPF?: string
    Nome: string
    email: string
    senha: string
  }

  export type ClienteUpdateManyMutationInput = {
    CPF?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type ClienteUncheckedUpdateManyInput = {
    CPF?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type PrestadorCreateInput = {
    CNPJ?: string
    Nome: string
    email: string
    Senha: string
    servicos?: ServicoCreateNestedManyWithoutPrestadorInput
  }

  export type PrestadorUncheckedCreateInput = {
    CNPJ?: string
    Nome: string
    email: string
    Senha: string
    servicos?: ServicoUncheckedCreateNestedManyWithoutPrestadorInput
  }

  export type PrestadorUpdateInput = {
    CNPJ?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    Senha?: StringFieldUpdateOperationsInput | string
    servicos?: ServicoUpdateManyWithoutPrestadorNestedInput
  }

  export type PrestadorUncheckedUpdateInput = {
    CNPJ?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    Senha?: StringFieldUpdateOperationsInput | string
    servicos?: ServicoUncheckedUpdateManyWithoutPrestadorNestedInput
  }

  export type PrestadorCreateManyInput = {
    CNPJ?: string
    Nome: string
    email: string
    Senha: string
  }

  export type PrestadorUpdateManyMutationInput = {
    CNPJ?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    Senha?: StringFieldUpdateOperationsInput | string
  }

  export type PrestadorUncheckedUpdateManyInput = {
    CNPJ?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    Senha?: StringFieldUpdateOperationsInput | string
  }

  export type ServicoCreateInput = {
    id?: string
    NomeServico: string
    preco: number
    descricao: string
    img: string
    prestador: PrestadorCreateNestedOneWithoutServicosInput
    categoria?: CategoriaCreateNestedManyWithoutServicoInput
  }

  export type ServicoUncheckedCreateInput = {
    id?: string
    NomeServico: string
    preco: number
    descricao: string
    img: string
    servicoId: string
    categoria?: CategoriaUncheckedCreateNestedManyWithoutServicoInput
  }

  export type ServicoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    NomeServico?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    prestador?: PrestadorUpdateOneRequiredWithoutServicosNestedInput
    categoria?: CategoriaUpdateManyWithoutServicoNestedInput
  }

  export type ServicoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    NomeServico?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    servicoId?: StringFieldUpdateOperationsInput | string
    categoria?: CategoriaUncheckedUpdateManyWithoutServicoNestedInput
  }

  export type ServicoCreateManyInput = {
    id?: string
    NomeServico: string
    preco: number
    descricao: string
    img: string
    servicoId: string
  }

  export type ServicoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    NomeServico?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
  }

  export type ServicoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    NomeServico?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    servicoId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaCreateInput = {
    id?: string
    nomeCategoria: string
    descricao: string
    servico?: ServicoCreateNestedOneWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateInput = {
    id?: string
    nomeCategoria: string
    descricao: string
    servicoId?: string | null
  }

  export type CategoriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    servico?: ServicoUpdateOneWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    servicoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoriaCreateManyInput = {
    id?: string
    nomeCategoria: string
    descricao: string
    servicoId?: string | null
  }

  export type CategoriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    servicoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgendaCreateInput = {
    id?: string
    horario: Date | string
    dia: Date | string
    agendado: AgendadoCreateNestedOneWithoutAgendaInput
  }

  export type AgendaUncheckedCreateInput = {
    id?: string
    horario: Date | string
    dia: Date | string
    agendaId: string
  }

  export type AgendaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    horario?: DateTimeFieldUpdateOperationsInput | Date | string
    dia?: DateTimeFieldUpdateOperationsInput | Date | string
    agendado?: AgendadoUpdateOneRequiredWithoutAgendaNestedInput
  }

  export type AgendaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    horario?: DateTimeFieldUpdateOperationsInput | Date | string
    dia?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaCreateManyInput = {
    id?: string
    horario: Date | string
    dia: Date | string
    agendaId: string
  }

  export type AgendaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    horario?: DateTimeFieldUpdateOperationsInput | Date | string
    dia?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    horario?: DateTimeFieldUpdateOperationsInput | Date | string
    dia?: DateTimeFieldUpdateOperationsInput | Date | string
    agendaId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaStatusCreateInput = {
    id?: string
    nomeStatus: string
    descricao: string
    agendado: AgendadoCreateNestedOneWithoutStatusInput
  }

  export type AgendaStatusUncheckedCreateInput = {
    id?: string
    nomeStatus: string
    descricao: string
    statusId: string
  }

  export type AgendaStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeStatus?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    agendado?: AgendadoUpdateOneRequiredWithoutStatusNestedInput
  }

  export type AgendaStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeStatus?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaStatusCreateManyInput = {
    id?: string
    nomeStatus: string
    descricao: string
    statusId: string
  }

  export type AgendaStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeStatus?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeStatus?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendadoCreateInput = {
    id?: string
    agendadoId: number
    status?: AgendaStatusCreateNestedManyWithoutAgendadoInput
    agenda?: AgendaCreateNestedManyWithoutAgendadoInput
  }

  export type AgendadoUncheckedCreateInput = {
    id?: string
    agendadoId: number
    status?: AgendaStatusUncheckedCreateNestedManyWithoutAgendadoInput
    agenda?: AgendaUncheckedCreateNestedManyWithoutAgendadoInput
  }

  export type AgendadoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agendadoId?: IntFieldUpdateOperationsInput | number
    status?: AgendaStatusUpdateManyWithoutAgendadoNestedInput
    agenda?: AgendaUpdateManyWithoutAgendadoNestedInput
  }

  export type AgendadoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agendadoId?: IntFieldUpdateOperationsInput | number
    status?: AgendaStatusUncheckedUpdateManyWithoutAgendadoNestedInput
    agenda?: AgendaUncheckedUpdateManyWithoutAgendadoNestedInput
  }

  export type AgendadoCreateManyInput = {
    id?: string
    agendadoId: number
  }

  export type AgendadoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agendadoId?: IntFieldUpdateOperationsInput | number
  }

  export type AgendadoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agendadoId?: IntFieldUpdateOperationsInput | number
  }

  export type ProdutosCreateInput = {
    id?: string
    nomeProduto: string
    preco: number
    descricao: string
  }

  export type ProdutosUncheckedCreateInput = {
    id?: string
    nomeProduto: string
    preco: number
    descricao: string
  }

  export type ProdutosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeProduto?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type ProdutosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeProduto?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type ProdutosCreateManyInput = {
    id?: string
    nomeProduto: string
    preco: number
    descricao: string
  }

  export type ProdutosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeProduto?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type ProdutosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeProduto?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type ClienteCountOrderByAggregateInput = {
    CPF?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    CPF?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    CPF?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type ServicoListRelationFilter = {
    every?: ServicoWhereInput
    some?: ServicoWhereInput
    none?: ServicoWhereInput
  }

  export type ServicoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrestadorCountOrderByAggregateInput = {
    CNPJ?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    Senha?: SortOrder
  }

  export type PrestadorMaxOrderByAggregateInput = {
    CNPJ?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    Senha?: SortOrder
  }

  export type PrestadorMinOrderByAggregateInput = {
    CNPJ?: SortOrder
    Nome?: SortOrder
    email?: SortOrder
    Senha?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type PrestadorRelationFilter = {
    is?: PrestadorWhereInput
    isNot?: PrestadorWhereInput
  }

  export type CategoriaListRelationFilter = {
    every?: CategoriaWhereInput
    some?: CategoriaWhereInput
    none?: CategoriaWhereInput
  }

  export type CategoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicoCountOrderByAggregateInput = {
    id?: SortOrder
    NomeServico?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
    img?: SortOrder
    servicoId?: SortOrder
  }

  export type ServicoAvgOrderByAggregateInput = {
    preco?: SortOrder
  }

  export type ServicoMaxOrderByAggregateInput = {
    id?: SortOrder
    NomeServico?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
    img?: SortOrder
    servicoId?: SortOrder
  }

  export type ServicoMinOrderByAggregateInput = {
    id?: SortOrder
    NomeServico?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
    img?: SortOrder
    servicoId?: SortOrder
  }

  export type ServicoSumOrderByAggregateInput = {
    preco?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type ServicoRelationFilter = {
    is?: ServicoWhereInput | null
    isNot?: ServicoWhereInput | null
  }

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nomeCategoria?: SortOrder
    descricao?: SortOrder
    servicoId?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nomeCategoria?: SortOrder
    descricao?: SortOrder
    servicoId?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nomeCategoria?: SortOrder
    descricao?: SortOrder
    servicoId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type AgendadoRelationFilter = {
    is?: AgendadoWhereInput
    isNot?: AgendadoWhereInput
  }

  export type AgendaCountOrderByAggregateInput = {
    id?: SortOrder
    horario?: SortOrder
    dia?: SortOrder
    agendaId?: SortOrder
  }

  export type AgendaMaxOrderByAggregateInput = {
    id?: SortOrder
    horario?: SortOrder
    dia?: SortOrder
    agendaId?: SortOrder
  }

  export type AgendaMinOrderByAggregateInput = {
    id?: SortOrder
    horario?: SortOrder
    dia?: SortOrder
    agendaId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type AgendaStatusCountOrderByAggregateInput = {
    id?: SortOrder
    nomeStatus?: SortOrder
    descricao?: SortOrder
    statusId?: SortOrder
  }

  export type AgendaStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    nomeStatus?: SortOrder
    descricao?: SortOrder
    statusId?: SortOrder
  }

  export type AgendaStatusMinOrderByAggregateInput = {
    id?: SortOrder
    nomeStatus?: SortOrder
    descricao?: SortOrder
    statusId?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type AgendaStatusListRelationFilter = {
    every?: AgendaStatusWhereInput
    some?: AgendaStatusWhereInput
    none?: AgendaStatusWhereInput
  }

  export type AgendaListRelationFilter = {
    every?: AgendaWhereInput
    some?: AgendaWhereInput
    none?: AgendaWhereInput
  }

  export type AgendaStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgendaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgendadoCountOrderByAggregateInput = {
    id?: SortOrder
    agendadoId?: SortOrder
  }

  export type AgendadoAvgOrderByAggregateInput = {
    agendadoId?: SortOrder
  }

  export type AgendadoMaxOrderByAggregateInput = {
    id?: SortOrder
    agendadoId?: SortOrder
  }

  export type AgendadoMinOrderByAggregateInput = {
    id?: SortOrder
    agendadoId?: SortOrder
  }

  export type AgendadoSumOrderByAggregateInput = {
    agendadoId?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type ProdutosCountOrderByAggregateInput = {
    id?: SortOrder
    nomeProduto?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
  }

  export type ProdutosAvgOrderByAggregateInput = {
    preco?: SortOrder
  }

  export type ProdutosMaxOrderByAggregateInput = {
    id?: SortOrder
    nomeProduto?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
  }

  export type ProdutosMinOrderByAggregateInput = {
    id?: SortOrder
    nomeProduto?: SortOrder
    preco?: SortOrder
    descricao?: SortOrder
  }

  export type ProdutosSumOrderByAggregateInput = {
    preco?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ServicoCreateNestedManyWithoutPrestadorInput = {
    create?: XOR<Enumerable<ServicoCreateWithoutPrestadorInput>, Enumerable<ServicoUncheckedCreateWithoutPrestadorInput>>
    connectOrCreate?: Enumerable<ServicoCreateOrConnectWithoutPrestadorInput>
    createMany?: ServicoCreateManyPrestadorInputEnvelope
    connect?: Enumerable<ServicoWhereUniqueInput>
  }

  export type ServicoUncheckedCreateNestedManyWithoutPrestadorInput = {
    create?: XOR<Enumerable<ServicoCreateWithoutPrestadorInput>, Enumerable<ServicoUncheckedCreateWithoutPrestadorInput>>
    connectOrCreate?: Enumerable<ServicoCreateOrConnectWithoutPrestadorInput>
    createMany?: ServicoCreateManyPrestadorInputEnvelope
    connect?: Enumerable<ServicoWhereUniqueInput>
  }

  export type ServicoUpdateManyWithoutPrestadorNestedInput = {
    create?: XOR<Enumerable<ServicoCreateWithoutPrestadorInput>, Enumerable<ServicoUncheckedCreateWithoutPrestadorInput>>
    connectOrCreate?: Enumerable<ServicoCreateOrConnectWithoutPrestadorInput>
    upsert?: Enumerable<ServicoUpsertWithWhereUniqueWithoutPrestadorInput>
    createMany?: ServicoCreateManyPrestadorInputEnvelope
    set?: Enumerable<ServicoWhereUniqueInput>
    disconnect?: Enumerable<ServicoWhereUniqueInput>
    delete?: Enumerable<ServicoWhereUniqueInput>
    connect?: Enumerable<ServicoWhereUniqueInput>
    update?: Enumerable<ServicoUpdateWithWhereUniqueWithoutPrestadorInput>
    updateMany?: Enumerable<ServicoUpdateManyWithWhereWithoutPrestadorInput>
    deleteMany?: Enumerable<ServicoScalarWhereInput>
  }

  export type ServicoUncheckedUpdateManyWithoutPrestadorNestedInput = {
    create?: XOR<Enumerable<ServicoCreateWithoutPrestadorInput>, Enumerable<ServicoUncheckedCreateWithoutPrestadorInput>>
    connectOrCreate?: Enumerable<ServicoCreateOrConnectWithoutPrestadorInput>
    upsert?: Enumerable<ServicoUpsertWithWhereUniqueWithoutPrestadorInput>
    createMany?: ServicoCreateManyPrestadorInputEnvelope
    set?: Enumerable<ServicoWhereUniqueInput>
    disconnect?: Enumerable<ServicoWhereUniqueInput>
    delete?: Enumerable<ServicoWhereUniqueInput>
    connect?: Enumerable<ServicoWhereUniqueInput>
    update?: Enumerable<ServicoUpdateWithWhereUniqueWithoutPrestadorInput>
    updateMany?: Enumerable<ServicoUpdateManyWithWhereWithoutPrestadorInput>
    deleteMany?: Enumerable<ServicoScalarWhereInput>
  }

  export type PrestadorCreateNestedOneWithoutServicosInput = {
    create?: XOR<PrestadorCreateWithoutServicosInput, PrestadorUncheckedCreateWithoutServicosInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutServicosInput
    connect?: PrestadorWhereUniqueInput
  }

  export type CategoriaCreateNestedManyWithoutServicoInput = {
    create?: XOR<Enumerable<CategoriaCreateWithoutServicoInput>, Enumerable<CategoriaUncheckedCreateWithoutServicoInput>>
    connectOrCreate?: Enumerable<CategoriaCreateOrConnectWithoutServicoInput>
    createMany?: CategoriaCreateManyServicoInputEnvelope
    connect?: Enumerable<CategoriaWhereUniqueInput>
  }

  export type CategoriaUncheckedCreateNestedManyWithoutServicoInput = {
    create?: XOR<Enumerable<CategoriaCreateWithoutServicoInput>, Enumerable<CategoriaUncheckedCreateWithoutServicoInput>>
    connectOrCreate?: Enumerable<CategoriaCreateOrConnectWithoutServicoInput>
    createMany?: CategoriaCreateManyServicoInputEnvelope
    connect?: Enumerable<CategoriaWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PrestadorUpdateOneRequiredWithoutServicosNestedInput = {
    create?: XOR<PrestadorCreateWithoutServicosInput, PrestadorUncheckedCreateWithoutServicosInput>
    connectOrCreate?: PrestadorCreateOrConnectWithoutServicosInput
    upsert?: PrestadorUpsertWithoutServicosInput
    connect?: PrestadorWhereUniqueInput
    update?: XOR<PrestadorUpdateWithoutServicosInput, PrestadorUncheckedUpdateWithoutServicosInput>
  }

  export type CategoriaUpdateManyWithoutServicoNestedInput = {
    create?: XOR<Enumerable<CategoriaCreateWithoutServicoInput>, Enumerable<CategoriaUncheckedCreateWithoutServicoInput>>
    connectOrCreate?: Enumerable<CategoriaCreateOrConnectWithoutServicoInput>
    upsert?: Enumerable<CategoriaUpsertWithWhereUniqueWithoutServicoInput>
    createMany?: CategoriaCreateManyServicoInputEnvelope
    set?: Enumerable<CategoriaWhereUniqueInput>
    disconnect?: Enumerable<CategoriaWhereUniqueInput>
    delete?: Enumerable<CategoriaWhereUniqueInput>
    connect?: Enumerable<CategoriaWhereUniqueInput>
    update?: Enumerable<CategoriaUpdateWithWhereUniqueWithoutServicoInput>
    updateMany?: Enumerable<CategoriaUpdateManyWithWhereWithoutServicoInput>
    deleteMany?: Enumerable<CategoriaScalarWhereInput>
  }

  export type CategoriaUncheckedUpdateManyWithoutServicoNestedInput = {
    create?: XOR<Enumerable<CategoriaCreateWithoutServicoInput>, Enumerable<CategoriaUncheckedCreateWithoutServicoInput>>
    connectOrCreate?: Enumerable<CategoriaCreateOrConnectWithoutServicoInput>
    upsert?: Enumerable<CategoriaUpsertWithWhereUniqueWithoutServicoInput>
    createMany?: CategoriaCreateManyServicoInputEnvelope
    set?: Enumerable<CategoriaWhereUniqueInput>
    disconnect?: Enumerable<CategoriaWhereUniqueInput>
    delete?: Enumerable<CategoriaWhereUniqueInput>
    connect?: Enumerable<CategoriaWhereUniqueInput>
    update?: Enumerable<CategoriaUpdateWithWhereUniqueWithoutServicoInput>
    updateMany?: Enumerable<CategoriaUpdateManyWithWhereWithoutServicoInput>
    deleteMany?: Enumerable<CategoriaScalarWhereInput>
  }

  export type ServicoCreateNestedOneWithoutCategoriaInput = {
    create?: XOR<ServicoCreateWithoutCategoriaInput, ServicoUncheckedCreateWithoutCategoriaInput>
    connectOrCreate?: ServicoCreateOrConnectWithoutCategoriaInput
    connect?: ServicoWhereUniqueInput
  }

  export type ServicoUpdateOneWithoutCategoriaNestedInput = {
    create?: XOR<ServicoCreateWithoutCategoriaInput, ServicoUncheckedCreateWithoutCategoriaInput>
    connectOrCreate?: ServicoCreateOrConnectWithoutCategoriaInput
    upsert?: ServicoUpsertWithoutCategoriaInput
    disconnect?: boolean
    delete?: boolean
    connect?: ServicoWhereUniqueInput
    update?: XOR<ServicoUpdateWithoutCategoriaInput, ServicoUncheckedUpdateWithoutCategoriaInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AgendadoCreateNestedOneWithoutAgendaInput = {
    create?: XOR<AgendadoCreateWithoutAgendaInput, AgendadoUncheckedCreateWithoutAgendaInput>
    connectOrCreate?: AgendadoCreateOrConnectWithoutAgendaInput
    connect?: AgendadoWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AgendadoUpdateOneRequiredWithoutAgendaNestedInput = {
    create?: XOR<AgendadoCreateWithoutAgendaInput, AgendadoUncheckedCreateWithoutAgendaInput>
    connectOrCreate?: AgendadoCreateOrConnectWithoutAgendaInput
    upsert?: AgendadoUpsertWithoutAgendaInput
    connect?: AgendadoWhereUniqueInput
    update?: XOR<AgendadoUpdateWithoutAgendaInput, AgendadoUncheckedUpdateWithoutAgendaInput>
  }

  export type AgendadoCreateNestedOneWithoutStatusInput = {
    create?: XOR<AgendadoCreateWithoutStatusInput, AgendadoUncheckedCreateWithoutStatusInput>
    connectOrCreate?: AgendadoCreateOrConnectWithoutStatusInput
    connect?: AgendadoWhereUniqueInput
  }

  export type AgendadoUpdateOneRequiredWithoutStatusNestedInput = {
    create?: XOR<AgendadoCreateWithoutStatusInput, AgendadoUncheckedCreateWithoutStatusInput>
    connectOrCreate?: AgendadoCreateOrConnectWithoutStatusInput
    upsert?: AgendadoUpsertWithoutStatusInput
    connect?: AgendadoWhereUniqueInput
    update?: XOR<AgendadoUpdateWithoutStatusInput, AgendadoUncheckedUpdateWithoutStatusInput>
  }

  export type AgendaStatusCreateNestedManyWithoutAgendadoInput = {
    create?: XOR<Enumerable<AgendaStatusCreateWithoutAgendadoInput>, Enumerable<AgendaStatusUncheckedCreateWithoutAgendadoInput>>
    connectOrCreate?: Enumerable<AgendaStatusCreateOrConnectWithoutAgendadoInput>
    createMany?: AgendaStatusCreateManyAgendadoInputEnvelope
    connect?: Enumerable<AgendaStatusWhereUniqueInput>
  }

  export type AgendaCreateNestedManyWithoutAgendadoInput = {
    create?: XOR<Enumerable<AgendaCreateWithoutAgendadoInput>, Enumerable<AgendaUncheckedCreateWithoutAgendadoInput>>
    connectOrCreate?: Enumerable<AgendaCreateOrConnectWithoutAgendadoInput>
    createMany?: AgendaCreateManyAgendadoInputEnvelope
    connect?: Enumerable<AgendaWhereUniqueInput>
  }

  export type AgendaStatusUncheckedCreateNestedManyWithoutAgendadoInput = {
    create?: XOR<Enumerable<AgendaStatusCreateWithoutAgendadoInput>, Enumerable<AgendaStatusUncheckedCreateWithoutAgendadoInput>>
    connectOrCreate?: Enumerable<AgendaStatusCreateOrConnectWithoutAgendadoInput>
    createMany?: AgendaStatusCreateManyAgendadoInputEnvelope
    connect?: Enumerable<AgendaStatusWhereUniqueInput>
  }

  export type AgendaUncheckedCreateNestedManyWithoutAgendadoInput = {
    create?: XOR<Enumerable<AgendaCreateWithoutAgendadoInput>, Enumerable<AgendaUncheckedCreateWithoutAgendadoInput>>
    connectOrCreate?: Enumerable<AgendaCreateOrConnectWithoutAgendadoInput>
    createMany?: AgendaCreateManyAgendadoInputEnvelope
    connect?: Enumerable<AgendaWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AgendaStatusUpdateManyWithoutAgendadoNestedInput = {
    create?: XOR<Enumerable<AgendaStatusCreateWithoutAgendadoInput>, Enumerable<AgendaStatusUncheckedCreateWithoutAgendadoInput>>
    connectOrCreate?: Enumerable<AgendaStatusCreateOrConnectWithoutAgendadoInput>
    upsert?: Enumerable<AgendaStatusUpsertWithWhereUniqueWithoutAgendadoInput>
    createMany?: AgendaStatusCreateManyAgendadoInputEnvelope
    set?: Enumerable<AgendaStatusWhereUniqueInput>
    disconnect?: Enumerable<AgendaStatusWhereUniqueInput>
    delete?: Enumerable<AgendaStatusWhereUniqueInput>
    connect?: Enumerable<AgendaStatusWhereUniqueInput>
    update?: Enumerable<AgendaStatusUpdateWithWhereUniqueWithoutAgendadoInput>
    updateMany?: Enumerable<AgendaStatusUpdateManyWithWhereWithoutAgendadoInput>
    deleteMany?: Enumerable<AgendaStatusScalarWhereInput>
  }

  export type AgendaUpdateManyWithoutAgendadoNestedInput = {
    create?: XOR<Enumerable<AgendaCreateWithoutAgendadoInput>, Enumerable<AgendaUncheckedCreateWithoutAgendadoInput>>
    connectOrCreate?: Enumerable<AgendaCreateOrConnectWithoutAgendadoInput>
    upsert?: Enumerable<AgendaUpsertWithWhereUniqueWithoutAgendadoInput>
    createMany?: AgendaCreateManyAgendadoInputEnvelope
    set?: Enumerable<AgendaWhereUniqueInput>
    disconnect?: Enumerable<AgendaWhereUniqueInput>
    delete?: Enumerable<AgendaWhereUniqueInput>
    connect?: Enumerable<AgendaWhereUniqueInput>
    update?: Enumerable<AgendaUpdateWithWhereUniqueWithoutAgendadoInput>
    updateMany?: Enumerable<AgendaUpdateManyWithWhereWithoutAgendadoInput>
    deleteMany?: Enumerable<AgendaScalarWhereInput>
  }

  export type AgendaStatusUncheckedUpdateManyWithoutAgendadoNestedInput = {
    create?: XOR<Enumerable<AgendaStatusCreateWithoutAgendadoInput>, Enumerable<AgendaStatusUncheckedCreateWithoutAgendadoInput>>
    connectOrCreate?: Enumerable<AgendaStatusCreateOrConnectWithoutAgendadoInput>
    upsert?: Enumerable<AgendaStatusUpsertWithWhereUniqueWithoutAgendadoInput>
    createMany?: AgendaStatusCreateManyAgendadoInputEnvelope
    set?: Enumerable<AgendaStatusWhereUniqueInput>
    disconnect?: Enumerable<AgendaStatusWhereUniqueInput>
    delete?: Enumerable<AgendaStatusWhereUniqueInput>
    connect?: Enumerable<AgendaStatusWhereUniqueInput>
    update?: Enumerable<AgendaStatusUpdateWithWhereUniqueWithoutAgendadoInput>
    updateMany?: Enumerable<AgendaStatusUpdateManyWithWhereWithoutAgendadoInput>
    deleteMany?: Enumerable<AgendaStatusScalarWhereInput>
  }

  export type AgendaUncheckedUpdateManyWithoutAgendadoNestedInput = {
    create?: XOR<Enumerable<AgendaCreateWithoutAgendadoInput>, Enumerable<AgendaUncheckedCreateWithoutAgendadoInput>>
    connectOrCreate?: Enumerable<AgendaCreateOrConnectWithoutAgendadoInput>
    upsert?: Enumerable<AgendaUpsertWithWhereUniqueWithoutAgendadoInput>
    createMany?: AgendaCreateManyAgendadoInputEnvelope
    set?: Enumerable<AgendaWhereUniqueInput>
    disconnect?: Enumerable<AgendaWhereUniqueInput>
    delete?: Enumerable<AgendaWhereUniqueInput>
    connect?: Enumerable<AgendaWhereUniqueInput>
    update?: Enumerable<AgendaUpdateWithWhereUniqueWithoutAgendadoInput>
    updateMany?: Enumerable<AgendaUpdateManyWithWhereWithoutAgendadoInput>
    deleteMany?: Enumerable<AgendaScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type ServicoCreateWithoutPrestadorInput = {
    id?: string
    NomeServico: string
    preco: number
    descricao: string
    img: string
    categoria?: CategoriaCreateNestedManyWithoutServicoInput
  }

  export type ServicoUncheckedCreateWithoutPrestadorInput = {
    id?: string
    NomeServico: string
    preco: number
    descricao: string
    img: string
    categoria?: CategoriaUncheckedCreateNestedManyWithoutServicoInput
  }

  export type ServicoCreateOrConnectWithoutPrestadorInput = {
    where: ServicoWhereUniqueInput
    create: XOR<ServicoCreateWithoutPrestadorInput, ServicoUncheckedCreateWithoutPrestadorInput>
  }

  export type ServicoCreateManyPrestadorInputEnvelope = {
    data: Enumerable<ServicoCreateManyPrestadorInput>
    skipDuplicates?: boolean
  }

  export type ServicoUpsertWithWhereUniqueWithoutPrestadorInput = {
    where: ServicoWhereUniqueInput
    update: XOR<ServicoUpdateWithoutPrestadorInput, ServicoUncheckedUpdateWithoutPrestadorInput>
    create: XOR<ServicoCreateWithoutPrestadorInput, ServicoUncheckedCreateWithoutPrestadorInput>
  }

  export type ServicoUpdateWithWhereUniqueWithoutPrestadorInput = {
    where: ServicoWhereUniqueInput
    data: XOR<ServicoUpdateWithoutPrestadorInput, ServicoUncheckedUpdateWithoutPrestadorInput>
  }

  export type ServicoUpdateManyWithWhereWithoutPrestadorInput = {
    where: ServicoScalarWhereInput
    data: XOR<ServicoUpdateManyMutationInput, ServicoUncheckedUpdateManyWithoutServicosInput>
  }

  export type ServicoScalarWhereInput = {
    AND?: Enumerable<ServicoScalarWhereInput>
    OR?: Enumerable<ServicoScalarWhereInput>
    NOT?: Enumerable<ServicoScalarWhereInput>
    id?: StringFilter | string
    NomeServico?: StringFilter | string
    preco?: FloatFilter | number
    descricao?: StringFilter | string
    img?: StringFilter | string
    servicoId?: StringFilter | string
  }

  export type PrestadorCreateWithoutServicosInput = {
    CNPJ?: string
    Nome: string
    email: string
    Senha: string
  }

  export type PrestadorUncheckedCreateWithoutServicosInput = {
    CNPJ?: string
    Nome: string
    email: string
    Senha: string
  }

  export type PrestadorCreateOrConnectWithoutServicosInput = {
    where: PrestadorWhereUniqueInput
    create: XOR<PrestadorCreateWithoutServicosInput, PrestadorUncheckedCreateWithoutServicosInput>
  }

  export type CategoriaCreateWithoutServicoInput = {
    id?: string
    nomeCategoria: string
    descricao: string
  }

  export type CategoriaUncheckedCreateWithoutServicoInput = {
    id?: string
    nomeCategoria: string
    descricao: string
  }

  export type CategoriaCreateOrConnectWithoutServicoInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutServicoInput, CategoriaUncheckedCreateWithoutServicoInput>
  }

  export type CategoriaCreateManyServicoInputEnvelope = {
    data: Enumerable<CategoriaCreateManyServicoInput>
    skipDuplicates?: boolean
  }

  export type PrestadorUpsertWithoutServicosInput = {
    update: XOR<PrestadorUpdateWithoutServicosInput, PrestadorUncheckedUpdateWithoutServicosInput>
    create: XOR<PrestadorCreateWithoutServicosInput, PrestadorUncheckedCreateWithoutServicosInput>
  }

  export type PrestadorUpdateWithoutServicosInput = {
    CNPJ?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    Senha?: StringFieldUpdateOperationsInput | string
  }

  export type PrestadorUncheckedUpdateWithoutServicosInput = {
    CNPJ?: StringFieldUpdateOperationsInput | string
    Nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    Senha?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUpsertWithWhereUniqueWithoutServicoInput = {
    where: CategoriaWhereUniqueInput
    update: XOR<CategoriaUpdateWithoutServicoInput, CategoriaUncheckedUpdateWithoutServicoInput>
    create: XOR<CategoriaCreateWithoutServicoInput, CategoriaUncheckedCreateWithoutServicoInput>
  }

  export type CategoriaUpdateWithWhereUniqueWithoutServicoInput = {
    where: CategoriaWhereUniqueInput
    data: XOR<CategoriaUpdateWithoutServicoInput, CategoriaUncheckedUpdateWithoutServicoInput>
  }

  export type CategoriaUpdateManyWithWhereWithoutServicoInput = {
    where: CategoriaScalarWhereInput
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type CategoriaScalarWhereInput = {
    AND?: Enumerable<CategoriaScalarWhereInput>
    OR?: Enumerable<CategoriaScalarWhereInput>
    NOT?: Enumerable<CategoriaScalarWhereInput>
    id?: StringFilter | string
    nomeCategoria?: StringFilter | string
    descricao?: StringFilter | string
    servicoId?: StringNullableFilter | string | null
  }

  export type ServicoCreateWithoutCategoriaInput = {
    id?: string
    NomeServico: string
    preco: number
    descricao: string
    img: string
    prestador: PrestadorCreateNestedOneWithoutServicosInput
  }

  export type ServicoUncheckedCreateWithoutCategoriaInput = {
    id?: string
    NomeServico: string
    preco: number
    descricao: string
    img: string
    servicoId: string
  }

  export type ServicoCreateOrConnectWithoutCategoriaInput = {
    where: ServicoWhereUniqueInput
    create: XOR<ServicoCreateWithoutCategoriaInput, ServicoUncheckedCreateWithoutCategoriaInput>
  }

  export type ServicoUpsertWithoutCategoriaInput = {
    update: XOR<ServicoUpdateWithoutCategoriaInput, ServicoUncheckedUpdateWithoutCategoriaInput>
    create: XOR<ServicoCreateWithoutCategoriaInput, ServicoUncheckedCreateWithoutCategoriaInput>
  }

  export type ServicoUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    NomeServico?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    prestador?: PrestadorUpdateOneRequiredWithoutServicosNestedInput
  }

  export type ServicoUncheckedUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    NomeServico?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    servicoId?: StringFieldUpdateOperationsInput | string
  }

  export type AgendadoCreateWithoutAgendaInput = {
    id?: string
    agendadoId: number
    status?: AgendaStatusCreateNestedManyWithoutAgendadoInput
  }

  export type AgendadoUncheckedCreateWithoutAgendaInput = {
    id?: string
    agendadoId: number
    status?: AgendaStatusUncheckedCreateNestedManyWithoutAgendadoInput
  }

  export type AgendadoCreateOrConnectWithoutAgendaInput = {
    where: AgendadoWhereUniqueInput
    create: XOR<AgendadoCreateWithoutAgendaInput, AgendadoUncheckedCreateWithoutAgendaInput>
  }

  export type AgendadoUpsertWithoutAgendaInput = {
    update: XOR<AgendadoUpdateWithoutAgendaInput, AgendadoUncheckedUpdateWithoutAgendaInput>
    create: XOR<AgendadoCreateWithoutAgendaInput, AgendadoUncheckedCreateWithoutAgendaInput>
  }

  export type AgendadoUpdateWithoutAgendaInput = {
    id?: StringFieldUpdateOperationsInput | string
    agendadoId?: IntFieldUpdateOperationsInput | number
    status?: AgendaStatusUpdateManyWithoutAgendadoNestedInput
  }

  export type AgendadoUncheckedUpdateWithoutAgendaInput = {
    id?: StringFieldUpdateOperationsInput | string
    agendadoId?: IntFieldUpdateOperationsInput | number
    status?: AgendaStatusUncheckedUpdateManyWithoutAgendadoNestedInput
  }

  export type AgendadoCreateWithoutStatusInput = {
    id?: string
    agendadoId: number
    agenda?: AgendaCreateNestedManyWithoutAgendadoInput
  }

  export type AgendadoUncheckedCreateWithoutStatusInput = {
    id?: string
    agendadoId: number
    agenda?: AgendaUncheckedCreateNestedManyWithoutAgendadoInput
  }

  export type AgendadoCreateOrConnectWithoutStatusInput = {
    where: AgendadoWhereUniqueInput
    create: XOR<AgendadoCreateWithoutStatusInput, AgendadoUncheckedCreateWithoutStatusInput>
  }

  export type AgendadoUpsertWithoutStatusInput = {
    update: XOR<AgendadoUpdateWithoutStatusInput, AgendadoUncheckedUpdateWithoutStatusInput>
    create: XOR<AgendadoCreateWithoutStatusInput, AgendadoUncheckedCreateWithoutStatusInput>
  }

  export type AgendadoUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    agendadoId?: IntFieldUpdateOperationsInput | number
    agenda?: AgendaUpdateManyWithoutAgendadoNestedInput
  }

  export type AgendadoUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    agendadoId?: IntFieldUpdateOperationsInput | number
    agenda?: AgendaUncheckedUpdateManyWithoutAgendadoNestedInput
  }

  export type AgendaStatusCreateWithoutAgendadoInput = {
    id?: string
    nomeStatus: string
    descricao: string
  }

  export type AgendaStatusUncheckedCreateWithoutAgendadoInput = {
    id?: string
    nomeStatus: string
    descricao: string
  }

  export type AgendaStatusCreateOrConnectWithoutAgendadoInput = {
    where: AgendaStatusWhereUniqueInput
    create: XOR<AgendaStatusCreateWithoutAgendadoInput, AgendaStatusUncheckedCreateWithoutAgendadoInput>
  }

  export type AgendaStatusCreateManyAgendadoInputEnvelope = {
    data: Enumerable<AgendaStatusCreateManyAgendadoInput>
    skipDuplicates?: boolean
  }

  export type AgendaCreateWithoutAgendadoInput = {
    id?: string
    horario: Date | string
    dia: Date | string
  }

  export type AgendaUncheckedCreateWithoutAgendadoInput = {
    id?: string
    horario: Date | string
    dia: Date | string
  }

  export type AgendaCreateOrConnectWithoutAgendadoInput = {
    where: AgendaWhereUniqueInput
    create: XOR<AgendaCreateWithoutAgendadoInput, AgendaUncheckedCreateWithoutAgendadoInput>
  }

  export type AgendaCreateManyAgendadoInputEnvelope = {
    data: Enumerable<AgendaCreateManyAgendadoInput>
    skipDuplicates?: boolean
  }

  export type AgendaStatusUpsertWithWhereUniqueWithoutAgendadoInput = {
    where: AgendaStatusWhereUniqueInput
    update: XOR<AgendaStatusUpdateWithoutAgendadoInput, AgendaStatusUncheckedUpdateWithoutAgendadoInput>
    create: XOR<AgendaStatusCreateWithoutAgendadoInput, AgendaStatusUncheckedCreateWithoutAgendadoInput>
  }

  export type AgendaStatusUpdateWithWhereUniqueWithoutAgendadoInput = {
    where: AgendaStatusWhereUniqueInput
    data: XOR<AgendaStatusUpdateWithoutAgendadoInput, AgendaStatusUncheckedUpdateWithoutAgendadoInput>
  }

  export type AgendaStatusUpdateManyWithWhereWithoutAgendadoInput = {
    where: AgendaStatusScalarWhereInput
    data: XOR<AgendaStatusUpdateManyMutationInput, AgendaStatusUncheckedUpdateManyWithoutStatusInput>
  }

  export type AgendaStatusScalarWhereInput = {
    AND?: Enumerable<AgendaStatusScalarWhereInput>
    OR?: Enumerable<AgendaStatusScalarWhereInput>
    NOT?: Enumerable<AgendaStatusScalarWhereInput>
    id?: StringFilter | string
    nomeStatus?: StringFilter | string
    descricao?: StringFilter | string
    statusId?: StringFilter | string
  }

  export type AgendaUpsertWithWhereUniqueWithoutAgendadoInput = {
    where: AgendaWhereUniqueInput
    update: XOR<AgendaUpdateWithoutAgendadoInput, AgendaUncheckedUpdateWithoutAgendadoInput>
    create: XOR<AgendaCreateWithoutAgendadoInput, AgendaUncheckedCreateWithoutAgendadoInput>
  }

  export type AgendaUpdateWithWhereUniqueWithoutAgendadoInput = {
    where: AgendaWhereUniqueInput
    data: XOR<AgendaUpdateWithoutAgendadoInput, AgendaUncheckedUpdateWithoutAgendadoInput>
  }

  export type AgendaUpdateManyWithWhereWithoutAgendadoInput = {
    where: AgendaScalarWhereInput
    data: XOR<AgendaUpdateManyMutationInput, AgendaUncheckedUpdateManyWithoutAgendaInput>
  }

  export type AgendaScalarWhereInput = {
    AND?: Enumerable<AgendaScalarWhereInput>
    OR?: Enumerable<AgendaScalarWhereInput>
    NOT?: Enumerable<AgendaScalarWhereInput>
    id?: StringFilter | string
    horario?: DateTimeFilter | Date | string
    dia?: DateTimeFilter | Date | string
    agendaId?: StringFilter | string
  }

  export type ServicoCreateManyPrestadorInput = {
    id?: string
    NomeServico: string
    preco: number
    descricao: string
    img: string
  }

  export type ServicoUpdateWithoutPrestadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    NomeServico?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    categoria?: CategoriaUpdateManyWithoutServicoNestedInput
  }

  export type ServicoUncheckedUpdateWithoutPrestadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    NomeServico?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    categoria?: CategoriaUncheckedUpdateManyWithoutServicoNestedInput
  }

  export type ServicoUncheckedUpdateManyWithoutServicosInput = {
    id?: StringFieldUpdateOperationsInput | string
    NomeServico?: StringFieldUpdateOperationsInput | string
    preco?: FloatFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaCreateManyServicoInput = {
    id?: string
    nomeCategoria: string
    descricao: string
  }

  export type CategoriaUpdateWithoutServicoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateWithoutServicoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaUncheckedUpdateManyWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeCategoria?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaStatusCreateManyAgendadoInput = {
    id?: string
    nomeStatus: string
    descricao: string
  }

  export type AgendaCreateManyAgendadoInput = {
    id?: string
    horario: Date | string
    dia: Date | string
  }

  export type AgendaStatusUpdateWithoutAgendadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeStatus?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaStatusUncheckedUpdateWithoutAgendadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeStatus?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaStatusUncheckedUpdateManyWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeStatus?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type AgendaUpdateWithoutAgendadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    horario?: DateTimeFieldUpdateOperationsInput | Date | string
    dia?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaUncheckedUpdateWithoutAgendadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    horario?: DateTimeFieldUpdateOperationsInput | Date | string
    dia?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgendaUncheckedUpdateManyWithoutAgendaInput = {
    id?: StringFieldUpdateOperationsInput | string
    horario?: DateTimeFieldUpdateOperationsInput | Date | string
    dia?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}